# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from dsr_msgs/RobotStateRT.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg

class RobotStateRT(genpy.Message):
  _md5sum = "3fc4bdbba50c12ddf9126a58ad825fc4"
  _type = "dsr_msgs/RobotStateRT"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# timestamp at the data of data acquisition
float64                      time_stamp
# actual joint position from incremental encoder at motor side(used for control) [deg]
float64[6]                   actual_joint_position
# actual joint position from absolute encoder at link side (used for exact link position) [deg]
float64[6]                   actual_joint_position_abs
# actual joint velocity from incremental encoder at motor side [deg/s]
float64[6]                   actual_joint_velocity
# actual joint velocity from absolute encoder at link side [deg/s]
float64[6]                   actual_joint_velocity_abs
# actual robot tcp position w.r.t. base coordinates: (x, y, z, a, b, c), where (a, b, c) follows Euler ZYZ notation [mm, deg]
float64[6]                   actual_tcp_position
# actual robot tcp velocity w.r.t. base coordinates [mm, deg/s]
float64[6]                   actual_tcp_velocity
# actual robot flange position w.r.t. base coordinates: (x, y, z, a, b, c), where (a, b, c) follows Euler ZYZ notation [mm, deg]
float64[6]                   actual_flange_position
# robot flange velocity w.r.t. base coordinates [mm, deg/s]
float64[6]                   actual_flange_velocity
# actual motor torque applying gear ratio = gear_ratio * current2torque_constant * motor current [Nm]
float64[6]                   actual_motor_torque
# estimated joint torque by robot controller [Nm]
float64[6]                   actual_joint_torque
# calibrated joint torque sensor data [Nm]
float64[6]                   raw_joint_torque
# calibrated force torque sensor data w.r.t. flange coordinates [N, Nm]
float64[6]                   raw_force_torque
# estimated external joint torque [Nm]
float64[6]                   external_joint_torque
# estimated tcp force w.r.t. base coordinates [N, Nm] 
float64[6]                   external_tcp_force
# target joint position [deg]
float64[6]                   target_joint_position
# target joint velocity [deg/s]
float64[6]                   target_joint_velocity
# target joint acceleration [deg/s^2] 
float64[6]                   target_joint_acceleration
# target motor torque [Nm] 
float64[6]                   target_motor_torque
# target tcp position w.r.t. base coordinates: (x, y, z, a, b, c), where (a, b, c) follows Euler ZYZ notation [mm, deg] 
float64[6]                   target_tcp_position
# target tcp velocity w.r.t. base coordinates [mm, deg/s]
float64[6]                   target_tcp_velocity
# jacobian matrix=J(q) w.r.t. base coordinates
std_msgs/Float64MultiArray[] jacobian_matrix
# gravity torque=g(q) [Nm]
float64[6]                   gravity_torque
# coriolis matrix=C(q,q_dot)  [6][6]
std_msgs/Float64MultiArray[] coriolis_matrix
# mass matrix=M(q) [6][6]
std_msgs/Float64MultiArray[] mass_matrix
# robot configuration 
uint16                       solution_space
# minimum singular value 
float64                      singularity
# current operation speed rate(1~100 %) 
float64                      operation_speed_rate
# joint temperature(celsius) 
float64[6]                   joint_temperature
# controller digital input(16 channel) 
uint16                       controller_digital_input
# controller digital output(16 channel) 
uint16                       controller_digital_output
# controller analog input type(2 channel) 
uint8[2]                      controller_analog_input_type
# controller analog input(2 channel) 
float64[2]                   controller_analog_input
# controller analog output type(2 channel) 
uint8[2]                     controller_analog_output_type
# controller analog output(2 channel) 
float64[2]                   controller_analog_output
# flange digital input(A-Series: 2 channel, M/H-Series: 6 channel) 
uint8                        flange_digital_input
# flange digital output(A-Series: 2 channel, M/H-Series: 6 channel) 
uint8                        flange_digital_output
# flange analog input(A-Series: 2 channel, M/H-Series: 4 channel) 
float64[4]                   flange_analog_input
# strobe count(increased by 1 when detecting setting edge) 
uint8[2]                     external_encoder_strobe_count
# external encoder count 
uint16[2]                    external_encoder_count
# final goal joint position (reserved) 
float64[6]                   goal_joint_position
# final goal tcp position (reserved) 
float64[6]                   goal_tcp_position
# ROBOT_MODE_MANUAL(0), ROBOT_MODE_AUTONOMOUS(1), ROBOT_MODE_MEASURE(2) 
uint8                        robot_mode
# STATE_INITIALIZING(0), STATE_STANDBY(1), STATE_MOVING(2), STATE_SAFE_OFF(3), STATE_TEACHING(4), STATE_SAFE_STOP(5), STATE_EMERGENCY_STOP, STATE_HOMMING, STATE_RECOVERY, STATE_SAFE_STOP2, STATE_SAFE_OFF2, 
uint8                        robot_state
# position control mode, torque mode 
uint16                       control_mode
# Reserved 
uint8[256]                   reserved
================================================================================
MSG: std_msgs/Float64MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
float64[]         data          # array of data


================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"""
  __slots__ = ['time_stamp','actual_joint_position','actual_joint_position_abs','actual_joint_velocity','actual_joint_velocity_abs','actual_tcp_position','actual_tcp_velocity','actual_flange_position','actual_flange_velocity','actual_motor_torque','actual_joint_torque','raw_joint_torque','raw_force_torque','external_joint_torque','external_tcp_force','target_joint_position','target_joint_velocity','target_joint_acceleration','target_motor_torque','target_tcp_position','target_tcp_velocity','jacobian_matrix','gravity_torque','coriolis_matrix','mass_matrix','solution_space','singularity','operation_speed_rate','joint_temperature','controller_digital_input','controller_digital_output','controller_analog_input_type','controller_analog_input','controller_analog_output_type','controller_analog_output','flange_digital_input','flange_digital_output','flange_analog_input','external_encoder_strobe_count','external_encoder_count','goal_joint_position','goal_tcp_position','robot_mode','robot_state','control_mode','reserved']
  _slot_types = ['float64','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','std_msgs/Float64MultiArray[]','float64[6]','std_msgs/Float64MultiArray[]','std_msgs/Float64MultiArray[]','uint16','float64','float64','float64[6]','uint16','uint16','uint8[2]','float64[2]','uint8[2]','float64[2]','uint8','uint8','float64[4]','uint8[2]','uint16[2]','float64[6]','float64[6]','uint8','uint8','uint16','uint8[256]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       time_stamp,actual_joint_position,actual_joint_position_abs,actual_joint_velocity,actual_joint_velocity_abs,actual_tcp_position,actual_tcp_velocity,actual_flange_position,actual_flange_velocity,actual_motor_torque,actual_joint_torque,raw_joint_torque,raw_force_torque,external_joint_torque,external_tcp_force,target_joint_position,target_joint_velocity,target_joint_acceleration,target_motor_torque,target_tcp_position,target_tcp_velocity,jacobian_matrix,gravity_torque,coriolis_matrix,mass_matrix,solution_space,singularity,operation_speed_rate,joint_temperature,controller_digital_input,controller_digital_output,controller_analog_input_type,controller_analog_input,controller_analog_output_type,controller_analog_output,flange_digital_input,flange_digital_output,flange_analog_input,external_encoder_strobe_count,external_encoder_count,goal_joint_position,goal_tcp_position,robot_mode,robot_state,control_mode,reserved

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(RobotStateRT, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.time_stamp is None:
        self.time_stamp = 0.
      if self.actual_joint_position is None:
        self.actual_joint_position = [0.] * 6
      if self.actual_joint_position_abs is None:
        self.actual_joint_position_abs = [0.] * 6
      if self.actual_joint_velocity is None:
        self.actual_joint_velocity = [0.] * 6
      if self.actual_joint_velocity_abs is None:
        self.actual_joint_velocity_abs = [0.] * 6
      if self.actual_tcp_position is None:
        self.actual_tcp_position = [0.] * 6
      if self.actual_tcp_velocity is None:
        self.actual_tcp_velocity = [0.] * 6
      if self.actual_flange_position is None:
        self.actual_flange_position = [0.] * 6
      if self.actual_flange_velocity is None:
        self.actual_flange_velocity = [0.] * 6
      if self.actual_motor_torque is None:
        self.actual_motor_torque = [0.] * 6
      if self.actual_joint_torque is None:
        self.actual_joint_torque = [0.] * 6
      if self.raw_joint_torque is None:
        self.raw_joint_torque = [0.] * 6
      if self.raw_force_torque is None:
        self.raw_force_torque = [0.] * 6
      if self.external_joint_torque is None:
        self.external_joint_torque = [0.] * 6
      if self.external_tcp_force is None:
        self.external_tcp_force = [0.] * 6
      if self.target_joint_position is None:
        self.target_joint_position = [0.] * 6
      if self.target_joint_velocity is None:
        self.target_joint_velocity = [0.] * 6
      if self.target_joint_acceleration is None:
        self.target_joint_acceleration = [0.] * 6
      if self.target_motor_torque is None:
        self.target_motor_torque = [0.] * 6
      if self.target_tcp_position is None:
        self.target_tcp_position = [0.] * 6
      if self.target_tcp_velocity is None:
        self.target_tcp_velocity = [0.] * 6
      if self.jacobian_matrix is None:
        self.jacobian_matrix = []
      if self.gravity_torque is None:
        self.gravity_torque = [0.] * 6
      if self.coriolis_matrix is None:
        self.coriolis_matrix = []
      if self.mass_matrix is None:
        self.mass_matrix = []
      if self.solution_space is None:
        self.solution_space = 0
      if self.singularity is None:
        self.singularity = 0.
      if self.operation_speed_rate is None:
        self.operation_speed_rate = 0.
      if self.joint_temperature is None:
        self.joint_temperature = [0.] * 6
      if self.controller_digital_input is None:
        self.controller_digital_input = 0
      if self.controller_digital_output is None:
        self.controller_digital_output = 0
      if self.controller_analog_input_type is None:
        self.controller_analog_input_type = b'\0'*2
      if self.controller_analog_input is None:
        self.controller_analog_input = [0.] * 2
      if self.controller_analog_output_type is None:
        self.controller_analog_output_type = b'\0'*2
      if self.controller_analog_output is None:
        self.controller_analog_output = [0.] * 2
      if self.flange_digital_input is None:
        self.flange_digital_input = 0
      if self.flange_digital_output is None:
        self.flange_digital_output = 0
      if self.flange_analog_input is None:
        self.flange_analog_input = [0.] * 4
      if self.external_encoder_strobe_count is None:
        self.external_encoder_strobe_count = b'\0'*2
      if self.external_encoder_count is None:
        self.external_encoder_count = [0] * 2
      if self.goal_joint_position is None:
        self.goal_joint_position = [0.] * 6
      if self.goal_tcp_position is None:
        self.goal_tcp_position = [0.] * 6
      if self.robot_mode is None:
        self.robot_mode = 0
      if self.robot_state is None:
        self.robot_state = 0
      if self.control_mode is None:
        self.control_mode = 0
      if self.reserved is None:
        self.reserved = b'\0'*256
    else:
      self.time_stamp = 0.
      self.actual_joint_position = [0.] * 6
      self.actual_joint_position_abs = [0.] * 6
      self.actual_joint_velocity = [0.] * 6
      self.actual_joint_velocity_abs = [0.] * 6
      self.actual_tcp_position = [0.] * 6
      self.actual_tcp_velocity = [0.] * 6
      self.actual_flange_position = [0.] * 6
      self.actual_flange_velocity = [0.] * 6
      self.actual_motor_torque = [0.] * 6
      self.actual_joint_torque = [0.] * 6
      self.raw_joint_torque = [0.] * 6
      self.raw_force_torque = [0.] * 6
      self.external_joint_torque = [0.] * 6
      self.external_tcp_force = [0.] * 6
      self.target_joint_position = [0.] * 6
      self.target_joint_velocity = [0.] * 6
      self.target_joint_acceleration = [0.] * 6
      self.target_motor_torque = [0.] * 6
      self.target_tcp_position = [0.] * 6
      self.target_tcp_velocity = [0.] * 6
      self.jacobian_matrix = []
      self.gravity_torque = [0.] * 6
      self.coriolis_matrix = []
      self.mass_matrix = []
      self.solution_space = 0
      self.singularity = 0.
      self.operation_speed_rate = 0.
      self.joint_temperature = [0.] * 6
      self.controller_digital_input = 0
      self.controller_digital_output = 0
      self.controller_analog_input_type = b'\0'*2
      self.controller_analog_input = [0.] * 2
      self.controller_analog_output_type = b'\0'*2
      self.controller_analog_output = [0.] * 2
      self.flange_digital_input = 0
      self.flange_digital_output = 0
      self.flange_analog_input = [0.] * 4
      self.external_encoder_strobe_count = b'\0'*2
      self.external_encoder_count = [0] * 2
      self.goal_joint_position = [0.] * 6
      self.goal_tcp_position = [0.] * 6
      self.robot_mode = 0
      self.robot_state = 0
      self.control_mode = 0
      self.reserved = b'\0'*256

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.time_stamp
      buff.write(_get_struct_d().pack(_x))
      buff.write(_get_struct_6d().pack(*self.actual_joint_position))
      buff.write(_get_struct_6d().pack(*self.actual_joint_position_abs))
      buff.write(_get_struct_6d().pack(*self.actual_joint_velocity))
      buff.write(_get_struct_6d().pack(*self.actual_joint_velocity_abs))
      buff.write(_get_struct_6d().pack(*self.actual_tcp_position))
      buff.write(_get_struct_6d().pack(*self.actual_tcp_velocity))
      buff.write(_get_struct_6d().pack(*self.actual_flange_position))
      buff.write(_get_struct_6d().pack(*self.actual_flange_velocity))
      buff.write(_get_struct_6d().pack(*self.actual_motor_torque))
      buff.write(_get_struct_6d().pack(*self.actual_joint_torque))
      buff.write(_get_struct_6d().pack(*self.raw_joint_torque))
      buff.write(_get_struct_6d().pack(*self.raw_force_torque))
      buff.write(_get_struct_6d().pack(*self.external_joint_torque))
      buff.write(_get_struct_6d().pack(*self.external_tcp_force))
      buff.write(_get_struct_6d().pack(*self.target_joint_position))
      buff.write(_get_struct_6d().pack(*self.target_joint_velocity))
      buff.write(_get_struct_6d().pack(*self.target_joint_acceleration))
      buff.write(_get_struct_6d().pack(*self.target_motor_torque))
      buff.write(_get_struct_6d().pack(*self.target_tcp_position))
      buff.write(_get_struct_6d().pack(*self.target_tcp_velocity))
      length = len(self.jacobian_matrix)
      buff.write(_struct_I.pack(length))
      for val1 in self.jacobian_matrix:
        _v1 = val1.layout
        length = len(_v1.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v1.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v1.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.data))
      buff.write(_get_struct_6d().pack(*self.gravity_torque))
      length = len(self.coriolis_matrix)
      buff.write(_struct_I.pack(length))
      for val1 in self.coriolis_matrix:
        _v2 = val1.layout
        length = len(_v2.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v2.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v2.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.data))
      length = len(self.mass_matrix)
      buff.write(_struct_I.pack(length))
      for val1 in self.mass_matrix:
        _v3 = val1.layout
        length = len(_v3.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v3.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v3.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.data))
      _x = self
      buff.write(_get_struct_H2d().pack(_x.solution_space, _x.singularity, _x.operation_speed_rate))
      buff.write(_get_struct_6d().pack(*self.joint_temperature))
      _x = self
      buff.write(_get_struct_2H().pack(_x.controller_digital_input, _x.controller_digital_output))
      _x = self.controller_analog_input_type
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_2B().pack(*_x))
      else:
        buff.write(_get_struct_2s().pack(_x))
      buff.write(_get_struct_2d().pack(*self.controller_analog_input))
      _x = self.controller_analog_output_type
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_2B().pack(*_x))
      else:
        buff.write(_get_struct_2s().pack(_x))
      buff.write(_get_struct_2d().pack(*self.controller_analog_output))
      _x = self
      buff.write(_get_struct_2B().pack(_x.flange_digital_input, _x.flange_digital_output))
      buff.write(_get_struct_4d().pack(*self.flange_analog_input))
      _x = self.external_encoder_strobe_count
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_2B().pack(*_x))
      else:
        buff.write(_get_struct_2s().pack(_x))
      buff.write(_get_struct_2H().pack(*self.external_encoder_count))
      buff.write(_get_struct_6d().pack(*self.goal_joint_position))
      buff.write(_get_struct_6d().pack(*self.goal_tcp_position))
      _x = self
      buff.write(_get_struct_2BH().pack(_x.robot_mode, _x.robot_state, _x.control_mode))
      _x = self.reserved
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_256B().pack(*_x))
      else:
        buff.write(_get_struct_256s().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.jacobian_matrix is None:
        self.jacobian_matrix = None
      if self.coriolis_matrix is None:
        self.coriolis_matrix = None
      if self.mass_matrix is None:
        self.mass_matrix = None
      end = 0
      start = end
      end += 8
      (self.time_stamp,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_joint_position = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_joint_position_abs = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_joint_velocity = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_joint_velocity_abs = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_tcp_position = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_tcp_velocity = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_flange_position = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_flange_velocity = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_motor_torque = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_joint_torque = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.raw_joint_torque = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.raw_force_torque = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.external_joint_torque = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.external_tcp_force = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.target_joint_position = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.target_joint_velocity = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.target_joint_acceleration = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.target_motor_torque = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.target_tcp_position = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.target_tcp_velocity = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.jacobian_matrix = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v4 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v4.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v4.dim.append(val3)
        start = end
        end += 4
        (_v4.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = s.unpack(str[start:end])
        self.jacobian_matrix.append(val1)
      start = end
      end += 48
      self.gravity_torque = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.coriolis_matrix = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v5 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v5.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v5.dim.append(val3)
        start = end
        end += 4
        (_v5.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = s.unpack(str[start:end])
        self.coriolis_matrix.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.mass_matrix = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v6 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v6.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v6.dim.append(val3)
        start = end
        end += 4
        (_v6.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = s.unpack(str[start:end])
        self.mass_matrix.append(val1)
      _x = self
      start = end
      end += 18
      (_x.solution_space, _x.singularity, _x.operation_speed_rate,) = _get_struct_H2d().unpack(str[start:end])
      start = end
      end += 48
      self.joint_temperature = _get_struct_6d().unpack(str[start:end])
      _x = self
      start = end
      end += 4
      (_x.controller_digital_input, _x.controller_digital_output,) = _get_struct_2H().unpack(str[start:end])
      start = end
      end += 2
      self.controller_analog_input_type = str[start:end]
      start = end
      end += 16
      self.controller_analog_input = _get_struct_2d().unpack(str[start:end])
      start = end
      end += 2
      self.controller_analog_output_type = str[start:end]
      start = end
      end += 16
      self.controller_analog_output = _get_struct_2d().unpack(str[start:end])
      _x = self
      start = end
      end += 2
      (_x.flange_digital_input, _x.flange_digital_output,) = _get_struct_2B().unpack(str[start:end])
      start = end
      end += 32
      self.flange_analog_input = _get_struct_4d().unpack(str[start:end])
      start = end
      end += 2
      self.external_encoder_strobe_count = str[start:end]
      start = end
      end += 4
      self.external_encoder_count = _get_struct_2H().unpack(str[start:end])
      start = end
      end += 48
      self.goal_joint_position = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.goal_tcp_position = _get_struct_6d().unpack(str[start:end])
      _x = self
      start = end
      end += 4
      (_x.robot_mode, _x.robot_state, _x.control_mode,) = _get_struct_2BH().unpack(str[start:end])
      start = end
      end += 256
      self.reserved = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.time_stamp
      buff.write(_get_struct_d().pack(_x))
      buff.write(self.actual_joint_position.tostring())
      buff.write(self.actual_joint_position_abs.tostring())
      buff.write(self.actual_joint_velocity.tostring())
      buff.write(self.actual_joint_velocity_abs.tostring())
      buff.write(self.actual_tcp_position.tostring())
      buff.write(self.actual_tcp_velocity.tostring())
      buff.write(self.actual_flange_position.tostring())
      buff.write(self.actual_flange_velocity.tostring())
      buff.write(self.actual_motor_torque.tostring())
      buff.write(self.actual_joint_torque.tostring())
      buff.write(self.raw_joint_torque.tostring())
      buff.write(self.raw_force_torque.tostring())
      buff.write(self.external_joint_torque.tostring())
      buff.write(self.external_tcp_force.tostring())
      buff.write(self.target_joint_position.tostring())
      buff.write(self.target_joint_velocity.tostring())
      buff.write(self.target_joint_acceleration.tostring())
      buff.write(self.target_motor_torque.tostring())
      buff.write(self.target_tcp_position.tostring())
      buff.write(self.target_tcp_velocity.tostring())
      length = len(self.jacobian_matrix)
      buff.write(_struct_I.pack(length))
      for val1 in self.jacobian_matrix:
        _v7 = val1.layout
        length = len(_v7.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v7.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v7.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.data.tostring())
      buff.write(self.gravity_torque.tostring())
      length = len(self.coriolis_matrix)
      buff.write(_struct_I.pack(length))
      for val1 in self.coriolis_matrix:
        _v8 = val1.layout
        length = len(_v8.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v8.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v8.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.data.tostring())
      length = len(self.mass_matrix)
      buff.write(_struct_I.pack(length))
      for val1 in self.mass_matrix:
        _v9 = val1.layout
        length = len(_v9.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v9.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v9.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.data.tostring())
      _x = self
      buff.write(_get_struct_H2d().pack(_x.solution_space, _x.singularity, _x.operation_speed_rate))
      buff.write(self.joint_temperature.tostring())
      _x = self
      buff.write(_get_struct_2H().pack(_x.controller_digital_input, _x.controller_digital_output))
      _x = self.controller_analog_input_type
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_2B().pack(*_x))
      else:
        buff.write(_get_struct_2s().pack(_x))
      buff.write(self.controller_analog_input.tostring())
      _x = self.controller_analog_output_type
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_2B().pack(*_x))
      else:
        buff.write(_get_struct_2s().pack(_x))
      buff.write(self.controller_analog_output.tostring())
      _x = self
      buff.write(_get_struct_2B().pack(_x.flange_digital_input, _x.flange_digital_output))
      buff.write(self.flange_analog_input.tostring())
      _x = self.external_encoder_strobe_count
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_2B().pack(*_x))
      else:
        buff.write(_get_struct_2s().pack(_x))
      buff.write(self.external_encoder_count.tostring())
      buff.write(self.goal_joint_position.tostring())
      buff.write(self.goal_tcp_position.tostring())
      _x = self
      buff.write(_get_struct_2BH().pack(_x.robot_mode, _x.robot_state, _x.control_mode))
      _x = self.reserved
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_256B().pack(*_x))
      else:
        buff.write(_get_struct_256s().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.jacobian_matrix is None:
        self.jacobian_matrix = None
      if self.coriolis_matrix is None:
        self.coriolis_matrix = None
      if self.mass_matrix is None:
        self.mass_matrix = None
      end = 0
      start = end
      end += 8
      (self.time_stamp,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_joint_position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_joint_position_abs = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_joint_velocity = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_joint_velocity_abs = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_tcp_position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_tcp_velocity = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_flange_position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_flange_velocity = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_motor_torque = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_joint_torque = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.raw_joint_torque = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.raw_force_torque = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.external_joint_torque = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.external_tcp_force = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.target_joint_position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.target_joint_velocity = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.target_joint_acceleration = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.target_motor_torque = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.target_tcp_position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.target_tcp_velocity = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.jacobian_matrix = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v10 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v10.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v10.dim.append(val3)
        start = end
        end += 4
        (_v10.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        self.jacobian_matrix.append(val1)
      start = end
      end += 48
      self.gravity_torque = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.coriolis_matrix = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v11 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v11.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v11.dim.append(val3)
        start = end
        end += 4
        (_v11.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        self.coriolis_matrix.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.mass_matrix = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v12 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v12.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v12.dim.append(val3)
        start = end
        end += 4
        (_v12.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        self.mass_matrix.append(val1)
      _x = self
      start = end
      end += 18
      (_x.solution_space, _x.singularity, _x.operation_speed_rate,) = _get_struct_H2d().unpack(str[start:end])
      start = end
      end += 48
      self.joint_temperature = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      _x = self
      start = end
      end += 4
      (_x.controller_digital_input, _x.controller_digital_output,) = _get_struct_2H().unpack(str[start:end])
      start = end
      end += 2
      self.controller_analog_input_type = str[start:end]
      start = end
      end += 16
      self.controller_analog_input = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=2)
      start = end
      end += 2
      self.controller_analog_output_type = str[start:end]
      start = end
      end += 16
      self.controller_analog_output = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=2)
      _x = self
      start = end
      end += 2
      (_x.flange_digital_input, _x.flange_digital_output,) = _get_struct_2B().unpack(str[start:end])
      start = end
      end += 32
      self.flange_analog_input = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=4)
      start = end
      end += 2
      self.external_encoder_strobe_count = str[start:end]
      start = end
      end += 4
      self.external_encoder_count = numpy.frombuffer(str[start:end], dtype=numpy.uint16, count=2)
      start = end
      end += 48
      self.goal_joint_position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.goal_tcp_position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      _x = self
      start = end
      end += 4
      (_x.robot_mode, _x.robot_state, _x.control_mode,) = _get_struct_2BH().unpack(str[start:end])
      start = end
      end += 256
      self.reserved = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_256B = None
def _get_struct_256B():
    global _struct_256B
    if _struct_256B is None:
        _struct_256B = struct.Struct("<256B")
    return _struct_256B
_struct_256s = None
def _get_struct_256s():
    global _struct_256s
    if _struct_256s is None:
        _struct_256s = struct.Struct("<256s")
    return _struct_256s
_struct_2B = None
def _get_struct_2B():
    global _struct_2B
    if _struct_2B is None:
        _struct_2B = struct.Struct("<2B")
    return _struct_2B
_struct_2BH = None
def _get_struct_2BH():
    global _struct_2BH
    if _struct_2BH is None:
        _struct_2BH = struct.Struct("<2BH")
    return _struct_2BH
_struct_2H = None
def _get_struct_2H():
    global _struct_2H
    if _struct_2H is None:
        _struct_2H = struct.Struct("<2H")
    return _struct_2H
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_2d = None
def _get_struct_2d():
    global _struct_2d
    if _struct_2d is None:
        _struct_2d = struct.Struct("<2d")
    return _struct_2d
_struct_2s = None
def _get_struct_2s():
    global _struct_2s
    if _struct_2s is None:
        _struct_2s = struct.Struct("<2s")
    return _struct_2s
_struct_4d = None
def _get_struct_4d():
    global _struct_4d
    if _struct_4d is None:
        _struct_4d = struct.Struct("<4d")
    return _struct_4d
_struct_6d = None
def _get_struct_6d():
    global _struct_6d
    if _struct_6d is None:
        _struct_6d = struct.Struct("<6d")
    return _struct_6d
_struct_H2d = None
def _get_struct_H2d():
    global _struct_H2d
    if _struct_H2d is None:
        _struct_H2d = struct.Struct("<H2d")
    return _struct_H2d
_struct_d = None
def _get_struct_d():
    global _struct_d
    if _struct_d is None:
        _struct_d = struct.Struct("<d")
    return _struct_d
