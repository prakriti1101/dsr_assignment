# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from dsr_msgs/RobotState.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import dsr_msgs.msg
import std_msgs.msg

class RobotState(genpy.Message):
  _md5sum = "0473bf35fc3b2d88cf36052d2ba4677e"
  _type = "dsr_msgs/RobotState"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """#____________________________________________________________________________________________
# state of robot
#____________________________________________________________________________________________

int32       robot_state             # 0 : STATE_INITIALIZING,   1 : STATE_STANDBY,   2 : STATE_MOVING,    3 : STATE_SAFE_OFF
                                    # 4 : STATE_TEACHING,       5 : STATE_SAFE_STOP, 6 : STATE_EMERGENCY_STOP,
                                    # 7 : STATE_EMERGENCY_STOP, 8 : STATE_HOMMING,   9 : STATE_RECOVERY,  10: STATE_SAFE_STOP2,     
                                    # 11: STATE_SAFE_OFF2,      12: STATE_RESERVED1, 13: STATE_RESERVED2, 14: STATE_RESERVED3,
                                    # 15: STATE_NOT_READY       16: STATE_LAST
string      robot_state_str         # Convert robot_state id to string

int8        actual_mode             # position control: 0, torque control: 1
int8        actual_space            # joint space: 0, task space: 1

float64[6]  current_posj            # current joint angle list [degree] 
float64[6]  current_velj            # current joint velocity list []
float64[6]  joint_abs               # Position Actual Value in ABS
float64[6]  joint_err               # Joint Error
float64[6]  target_posj             # target joint angle list [degree] 
float64[6]  target_velj             # target joint velocity list []

float64[6]  current_posx            # current task angle list []
float64[6]  current_tool_posx       # current task tool angle list []
float64[6]  current_velx            # current task velocity list []
float64[6]  task_err                # Task Error
float64[6]  target_velx             # target task velocity list []       
float64[6]  target_posx             # target task position list []
  
float64[6]  dynamic_tor             # dynamic torque
float64[6]  actual_jts              # joint torque sensor
float64[6]  actual_ejt              # external joint torque
float64[6]  actual_ett              # external tool torque

int8[6]     actual_bk               # brake status 
float64[6]  actual_mc               # motor current 
float64[6]  actual_mt               # motor temperature

int8        solution_space          # Solution Space (0 ~ 7)
float64     sync_time               # internal clock counter   
int8[5]     actual_bt               # cockpit(robot button) info.
std_msgs/Float64MultiArray[] rotation_matrix  # Rotation Matrix [3][3]


int8[16]    ctrlbox_digital_input   # Digital Input in Control Box(0 ~ 15 ; 0 : ON, 1 : OFF)
int8[16]    ctrlbox_digital_output  # Digital Output in Control Box(0 ~ 15 ; 0 : ON, 1 : OFF)

int8[6]     flange_digital_input    # Digital Input in Flange(0 ~ 5 ; 0 : ON, 1 : OFF) x1 port : 0 ~ 2, x2 port : 3 ~ 5
int8[6]     flange_digital_output   # Digital Output in Flange(0 ~ 5 ; 0 : ON, 1 : OFF)

ModbusState[] modbus_state          # Custom msg for modbus state(refer to ModbusState.msg)
int32 	    access_control          # 
bool	    homming_completed       #
bool	    tp_initialized          #
int8	    mastering_need          #
bool	    drl_stopped             #
bool	    disconnected            #

#____________________________________________________________________________________________
# The following messages have been updated since version M2.50 or higher.
#____________________________________________________________________________________________
float64[6]  fActualW2B                               # world to base releation
std_msgs/Float64MultiArray[] fCurrentPosW            # Wolrd position actual value [2][6] : (0: tool, 1: flange) [mm, degree] 
float64[6]  fCurrentVelW                             # World velocity Actual Value [mm/sec, degree/sec]
float64[6]  fWorldETT                                # External Task Force/Torque [N, Nm]
float64[6]  fTargetPosW                              # World target Position [mm, degree]
float64[6]  fTargetVelW                              # World target Velocity [mm/sec, degree/sec]
std_msgs/Float64MultiArray[] fRotationMatrixWorld    # World rotation matrix [3][3]
int8        iActualUCN                               # Actual user coord number ## 101 ~ 120
int8        iParent                                  # Coordinate Reference(base : 0  world : 2)
std_msgs/Float64MultiArray[] fCurrentPosU            # User position Actual Value [2][6] : (0:tool, 1:flange) [mm, degree]
float64[6]  fCurrentVelU                             # User velocity Actual Value [mm/sec, degree/sec]
float64[6]  fUserETT                                 # External Task Force/Torque [N, Nm]
float64[6]  fTargetPosU                              # User target Position [mm, degree]
float64[6]  fTargetVelU                              # User target Velocity [mm/sec, degree/sec]
std_msgs/Float64MultiArray[] fRotationMatrixUser     # User rotation matrix [3][3] 
float64[6]  fActualAI                                # Analog input data ## Current mode : 0~20.0[mA] , Voltage mode : 0~10.0[V]
bool[3]     bActualSW                                # Switch input data[3] 
bool[2]     bActualSI                                # Safety input data[2]
int8[2]     iActualAT                                # Analog input type[2]  index = channel, type: current(0), voltage(1)  
float64[2]    fTargetAO                              # Analog output data ## Current mode : 0~20.0[mA] , Voltage mode : 0~10.0[V]
int8[2]     iTargetAT                                # Analog output type[2] index = channel, type: current(0), voltage(1)
bool[2]     bActualES                                # Encorder strove signal
int8[2]     iActualED                                # Encorder raw data   
bool[2]     bActualER                                # Encorder reset signal

================================================================================
MSG: std_msgs/Float64MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
float64[]         data          # array of data


================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: dsr_msgs/ModbusState
#____________________________________________________________________________________________
#Custom msg for RobotState.msg -- MAX_SIZE = 100
#____________________________________________________________________________________________

string  modbus_symbol    # Modbus Signal Name
int32   modbus_value     # Modbus Register Value (Unsigned : 0 ~ 65535)"""
  __slots__ = ['robot_state','robot_state_str','actual_mode','actual_space','current_posj','current_velj','joint_abs','joint_err','target_posj','target_velj','current_posx','current_tool_posx','current_velx','task_err','target_velx','target_posx','dynamic_tor','actual_jts','actual_ejt','actual_ett','actual_bk','actual_mc','actual_mt','solution_space','sync_time','actual_bt','rotation_matrix','ctrlbox_digital_input','ctrlbox_digital_output','flange_digital_input','flange_digital_output','modbus_state','access_control','homming_completed','tp_initialized','mastering_need','drl_stopped','disconnected','fActualW2B','fCurrentPosW','fCurrentVelW','fWorldETT','fTargetPosW','fTargetVelW','fRotationMatrixWorld','iActualUCN','iParent','fCurrentPosU','fCurrentVelU','fUserETT','fTargetPosU','fTargetVelU','fRotationMatrixUser','fActualAI','bActualSW','bActualSI','iActualAT','fTargetAO','iTargetAT','bActualES','iActualED','bActualER']
  _slot_types = ['int32','string','int8','int8','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','float64[6]','int8[6]','float64[6]','float64[6]','int8','float64','int8[5]','std_msgs/Float64MultiArray[]','int8[16]','int8[16]','int8[6]','int8[6]','dsr_msgs/ModbusState[]','int32','bool','bool','int8','bool','bool','float64[6]','std_msgs/Float64MultiArray[]','float64[6]','float64[6]','float64[6]','float64[6]','std_msgs/Float64MultiArray[]','int8','int8','std_msgs/Float64MultiArray[]','float64[6]','float64[6]','float64[6]','float64[6]','std_msgs/Float64MultiArray[]','float64[6]','bool[3]','bool[2]','int8[2]','float64[2]','int8[2]','bool[2]','int8[2]','bool[2]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       robot_state,robot_state_str,actual_mode,actual_space,current_posj,current_velj,joint_abs,joint_err,target_posj,target_velj,current_posx,current_tool_posx,current_velx,task_err,target_velx,target_posx,dynamic_tor,actual_jts,actual_ejt,actual_ett,actual_bk,actual_mc,actual_mt,solution_space,sync_time,actual_bt,rotation_matrix,ctrlbox_digital_input,ctrlbox_digital_output,flange_digital_input,flange_digital_output,modbus_state,access_control,homming_completed,tp_initialized,mastering_need,drl_stopped,disconnected,fActualW2B,fCurrentPosW,fCurrentVelW,fWorldETT,fTargetPosW,fTargetVelW,fRotationMatrixWorld,iActualUCN,iParent,fCurrentPosU,fCurrentVelU,fUserETT,fTargetPosU,fTargetVelU,fRotationMatrixUser,fActualAI,bActualSW,bActualSI,iActualAT,fTargetAO,iTargetAT,bActualES,iActualED,bActualER

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(RobotState, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.robot_state is None:
        self.robot_state = 0
      if self.robot_state_str is None:
        self.robot_state_str = ''
      if self.actual_mode is None:
        self.actual_mode = 0
      if self.actual_space is None:
        self.actual_space = 0
      if self.current_posj is None:
        self.current_posj = [0.] * 6
      if self.current_velj is None:
        self.current_velj = [0.] * 6
      if self.joint_abs is None:
        self.joint_abs = [0.] * 6
      if self.joint_err is None:
        self.joint_err = [0.] * 6
      if self.target_posj is None:
        self.target_posj = [0.] * 6
      if self.target_velj is None:
        self.target_velj = [0.] * 6
      if self.current_posx is None:
        self.current_posx = [0.] * 6
      if self.current_tool_posx is None:
        self.current_tool_posx = [0.] * 6
      if self.current_velx is None:
        self.current_velx = [0.] * 6
      if self.task_err is None:
        self.task_err = [0.] * 6
      if self.target_velx is None:
        self.target_velx = [0.] * 6
      if self.target_posx is None:
        self.target_posx = [0.] * 6
      if self.dynamic_tor is None:
        self.dynamic_tor = [0.] * 6
      if self.actual_jts is None:
        self.actual_jts = [0.] * 6
      if self.actual_ejt is None:
        self.actual_ejt = [0.] * 6
      if self.actual_ett is None:
        self.actual_ett = [0.] * 6
      if self.actual_bk is None:
        self.actual_bk = [0] * 6
      if self.actual_mc is None:
        self.actual_mc = [0.] * 6
      if self.actual_mt is None:
        self.actual_mt = [0.] * 6
      if self.solution_space is None:
        self.solution_space = 0
      if self.sync_time is None:
        self.sync_time = 0.
      if self.actual_bt is None:
        self.actual_bt = [0] * 5
      if self.rotation_matrix is None:
        self.rotation_matrix = []
      if self.ctrlbox_digital_input is None:
        self.ctrlbox_digital_input = [0] * 16
      if self.ctrlbox_digital_output is None:
        self.ctrlbox_digital_output = [0] * 16
      if self.flange_digital_input is None:
        self.flange_digital_input = [0] * 6
      if self.flange_digital_output is None:
        self.flange_digital_output = [0] * 6
      if self.modbus_state is None:
        self.modbus_state = []
      if self.access_control is None:
        self.access_control = 0
      if self.homming_completed is None:
        self.homming_completed = False
      if self.tp_initialized is None:
        self.tp_initialized = False
      if self.mastering_need is None:
        self.mastering_need = 0
      if self.drl_stopped is None:
        self.drl_stopped = False
      if self.disconnected is None:
        self.disconnected = False
      if self.fActualW2B is None:
        self.fActualW2B = [0.] * 6
      if self.fCurrentPosW is None:
        self.fCurrentPosW = []
      if self.fCurrentVelW is None:
        self.fCurrentVelW = [0.] * 6
      if self.fWorldETT is None:
        self.fWorldETT = [0.] * 6
      if self.fTargetPosW is None:
        self.fTargetPosW = [0.] * 6
      if self.fTargetVelW is None:
        self.fTargetVelW = [0.] * 6
      if self.fRotationMatrixWorld is None:
        self.fRotationMatrixWorld = []
      if self.iActualUCN is None:
        self.iActualUCN = 0
      if self.iParent is None:
        self.iParent = 0
      if self.fCurrentPosU is None:
        self.fCurrentPosU = []
      if self.fCurrentVelU is None:
        self.fCurrentVelU = [0.] * 6
      if self.fUserETT is None:
        self.fUserETT = [0.] * 6
      if self.fTargetPosU is None:
        self.fTargetPosU = [0.] * 6
      if self.fTargetVelU is None:
        self.fTargetVelU = [0.] * 6
      if self.fRotationMatrixUser is None:
        self.fRotationMatrixUser = []
      if self.fActualAI is None:
        self.fActualAI = [0.] * 6
      if self.bActualSW is None:
        self.bActualSW = [False] * 3
      if self.bActualSI is None:
        self.bActualSI = [False] * 2
      if self.iActualAT is None:
        self.iActualAT = [0] * 2
      if self.fTargetAO is None:
        self.fTargetAO = [0.] * 2
      if self.iTargetAT is None:
        self.iTargetAT = [0] * 2
      if self.bActualES is None:
        self.bActualES = [False] * 2
      if self.iActualED is None:
        self.iActualED = [0] * 2
      if self.bActualER is None:
        self.bActualER = [False] * 2
    else:
      self.robot_state = 0
      self.robot_state_str = ''
      self.actual_mode = 0
      self.actual_space = 0
      self.current_posj = [0.] * 6
      self.current_velj = [0.] * 6
      self.joint_abs = [0.] * 6
      self.joint_err = [0.] * 6
      self.target_posj = [0.] * 6
      self.target_velj = [0.] * 6
      self.current_posx = [0.] * 6
      self.current_tool_posx = [0.] * 6
      self.current_velx = [0.] * 6
      self.task_err = [0.] * 6
      self.target_velx = [0.] * 6
      self.target_posx = [0.] * 6
      self.dynamic_tor = [0.] * 6
      self.actual_jts = [0.] * 6
      self.actual_ejt = [0.] * 6
      self.actual_ett = [0.] * 6
      self.actual_bk = [0] * 6
      self.actual_mc = [0.] * 6
      self.actual_mt = [0.] * 6
      self.solution_space = 0
      self.sync_time = 0.
      self.actual_bt = [0] * 5
      self.rotation_matrix = []
      self.ctrlbox_digital_input = [0] * 16
      self.ctrlbox_digital_output = [0] * 16
      self.flange_digital_input = [0] * 6
      self.flange_digital_output = [0] * 6
      self.modbus_state = []
      self.access_control = 0
      self.homming_completed = False
      self.tp_initialized = False
      self.mastering_need = 0
      self.drl_stopped = False
      self.disconnected = False
      self.fActualW2B = [0.] * 6
      self.fCurrentPosW = []
      self.fCurrentVelW = [0.] * 6
      self.fWorldETT = [0.] * 6
      self.fTargetPosW = [0.] * 6
      self.fTargetVelW = [0.] * 6
      self.fRotationMatrixWorld = []
      self.iActualUCN = 0
      self.iParent = 0
      self.fCurrentPosU = []
      self.fCurrentVelU = [0.] * 6
      self.fUserETT = [0.] * 6
      self.fTargetPosU = [0.] * 6
      self.fTargetVelU = [0.] * 6
      self.fRotationMatrixUser = []
      self.fActualAI = [0.] * 6
      self.bActualSW = [False] * 3
      self.bActualSI = [False] * 2
      self.iActualAT = [0] * 2
      self.fTargetAO = [0.] * 2
      self.iTargetAT = [0] * 2
      self.bActualES = [False] * 2
      self.iActualED = [0] * 2
      self.bActualER = [False] * 2

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.robot_state
      buff.write(_get_struct_i().pack(_x))
      _x = self.robot_state_str
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2b().pack(_x.actual_mode, _x.actual_space))
      buff.write(_get_struct_6d().pack(*self.current_posj))
      buff.write(_get_struct_6d().pack(*self.current_velj))
      buff.write(_get_struct_6d().pack(*self.joint_abs))
      buff.write(_get_struct_6d().pack(*self.joint_err))
      buff.write(_get_struct_6d().pack(*self.target_posj))
      buff.write(_get_struct_6d().pack(*self.target_velj))
      buff.write(_get_struct_6d().pack(*self.current_posx))
      buff.write(_get_struct_6d().pack(*self.current_tool_posx))
      buff.write(_get_struct_6d().pack(*self.current_velx))
      buff.write(_get_struct_6d().pack(*self.task_err))
      buff.write(_get_struct_6d().pack(*self.target_velx))
      buff.write(_get_struct_6d().pack(*self.target_posx))
      buff.write(_get_struct_6d().pack(*self.dynamic_tor))
      buff.write(_get_struct_6d().pack(*self.actual_jts))
      buff.write(_get_struct_6d().pack(*self.actual_ejt))
      buff.write(_get_struct_6d().pack(*self.actual_ett))
      buff.write(_get_struct_6b().pack(*self.actual_bk))
      buff.write(_get_struct_6d().pack(*self.actual_mc))
      buff.write(_get_struct_6d().pack(*self.actual_mt))
      _x = self
      buff.write(_get_struct_bd().pack(_x.solution_space, _x.sync_time))
      buff.write(_get_struct_5b().pack(*self.actual_bt))
      length = len(self.rotation_matrix)
      buff.write(_struct_I.pack(length))
      for val1 in self.rotation_matrix:
        _v1 = val1.layout
        length = len(_v1.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v1.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v1.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.data))
      buff.write(_get_struct_16b().pack(*self.ctrlbox_digital_input))
      buff.write(_get_struct_16b().pack(*self.ctrlbox_digital_output))
      buff.write(_get_struct_6b().pack(*self.flange_digital_input))
      buff.write(_get_struct_6b().pack(*self.flange_digital_output))
      length = len(self.modbus_state)
      buff.write(_struct_I.pack(length))
      for val1 in self.modbus_state:
        _x = val1.modbus_symbol
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.modbus_value
        buff.write(_get_struct_i().pack(_x))
      _x = self
      buff.write(_get_struct_i2Bb2B().pack(_x.access_control, _x.homming_completed, _x.tp_initialized, _x.mastering_need, _x.drl_stopped, _x.disconnected))
      buff.write(_get_struct_6d().pack(*self.fActualW2B))
      length = len(self.fCurrentPosW)
      buff.write(_struct_I.pack(length))
      for val1 in self.fCurrentPosW:
        _v2 = val1.layout
        length = len(_v2.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v2.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v2.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.data))
      buff.write(_get_struct_6d().pack(*self.fCurrentVelW))
      buff.write(_get_struct_6d().pack(*self.fWorldETT))
      buff.write(_get_struct_6d().pack(*self.fTargetPosW))
      buff.write(_get_struct_6d().pack(*self.fTargetVelW))
      length = len(self.fRotationMatrixWorld)
      buff.write(_struct_I.pack(length))
      for val1 in self.fRotationMatrixWorld:
        _v3 = val1.layout
        length = len(_v3.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v3.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v3.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.data))
      _x = self
      buff.write(_get_struct_2b().pack(_x.iActualUCN, _x.iParent))
      length = len(self.fCurrentPosU)
      buff.write(_struct_I.pack(length))
      for val1 in self.fCurrentPosU:
        _v4 = val1.layout
        length = len(_v4.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v4.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v4.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.data))
      buff.write(_get_struct_6d().pack(*self.fCurrentVelU))
      buff.write(_get_struct_6d().pack(*self.fUserETT))
      buff.write(_get_struct_6d().pack(*self.fTargetPosU))
      buff.write(_get_struct_6d().pack(*self.fTargetVelU))
      length = len(self.fRotationMatrixUser)
      buff.write(_struct_I.pack(length))
      for val1 in self.fRotationMatrixUser:
        _v5 = val1.layout
        length = len(_v5.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v5.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v5.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.data))
      buff.write(_get_struct_6d().pack(*self.fActualAI))
      buff.write(_get_struct_3B().pack(*self.bActualSW))
      buff.write(_get_struct_2B().pack(*self.bActualSI))
      buff.write(_get_struct_2b().pack(*self.iActualAT))
      buff.write(_get_struct_2d().pack(*self.fTargetAO))
      buff.write(_get_struct_2b().pack(*self.iTargetAT))
      buff.write(_get_struct_2B().pack(*self.bActualES))
      buff.write(_get_struct_2b().pack(*self.iActualED))
      buff.write(_get_struct_2B().pack(*self.bActualER))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.rotation_matrix is None:
        self.rotation_matrix = None
      if self.modbus_state is None:
        self.modbus_state = None
      if self.fCurrentPosW is None:
        self.fCurrentPosW = None
      if self.fRotationMatrixWorld is None:
        self.fRotationMatrixWorld = None
      if self.fCurrentPosU is None:
        self.fCurrentPosU = None
      if self.fRotationMatrixUser is None:
        self.fRotationMatrixUser = None
      end = 0
      start = end
      end += 4
      (self.robot_state,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.robot_state_str = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.robot_state_str = str[start:end]
      _x = self
      start = end
      end += 2
      (_x.actual_mode, _x.actual_space,) = _get_struct_2b().unpack(str[start:end])
      start = end
      end += 48
      self.current_posj = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.current_velj = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.joint_abs = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.joint_err = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.target_posj = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.target_velj = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.current_posx = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.current_tool_posx = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.current_velx = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.task_err = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.target_velx = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.target_posx = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.dynamic_tor = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_jts = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_ejt = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_ett = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 6
      self.actual_bk = _get_struct_6b().unpack(str[start:end])
      start = end
      end += 48
      self.actual_mc = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.actual_mt = _get_struct_6d().unpack(str[start:end])
      _x = self
      start = end
      end += 9
      (_x.solution_space, _x.sync_time,) = _get_struct_bd().unpack(str[start:end])
      start = end
      end += 5
      self.actual_bt = _get_struct_5b().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.rotation_matrix = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v6 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v6.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v6.dim.append(val3)
        start = end
        end += 4
        (_v6.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = s.unpack(str[start:end])
        self.rotation_matrix.append(val1)
      start = end
      end += 16
      self.ctrlbox_digital_input = _get_struct_16b().unpack(str[start:end])
      start = end
      end += 16
      self.ctrlbox_digital_output = _get_struct_16b().unpack(str[start:end])
      start = end
      end += 6
      self.flange_digital_input = _get_struct_6b().unpack(str[start:end])
      start = end
      end += 6
      self.flange_digital_output = _get_struct_6b().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.modbus_state = []
      for i in range(0, length):
        val1 = dsr_msgs.msg.ModbusState()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.modbus_symbol = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.modbus_symbol = str[start:end]
        start = end
        end += 4
        (val1.modbus_value,) = _get_struct_i().unpack(str[start:end])
        self.modbus_state.append(val1)
      _x = self
      start = end
      end += 9
      (_x.access_control, _x.homming_completed, _x.tp_initialized, _x.mastering_need, _x.drl_stopped, _x.disconnected,) = _get_struct_i2Bb2B().unpack(str[start:end])
      self.homming_completed = bool(self.homming_completed)
      self.tp_initialized = bool(self.tp_initialized)
      self.drl_stopped = bool(self.drl_stopped)
      self.disconnected = bool(self.disconnected)
      start = end
      end += 48
      self.fActualW2B = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.fCurrentPosW = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v7 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v7.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v7.dim.append(val3)
        start = end
        end += 4
        (_v7.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = s.unpack(str[start:end])
        self.fCurrentPosW.append(val1)
      start = end
      end += 48
      self.fCurrentVelW = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.fWorldETT = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.fTargetPosW = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.fTargetVelW = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.fRotationMatrixWorld = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v8 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v8.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v8.dim.append(val3)
        start = end
        end += 4
        (_v8.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = s.unpack(str[start:end])
        self.fRotationMatrixWorld.append(val1)
      _x = self
      start = end
      end += 2
      (_x.iActualUCN, _x.iParent,) = _get_struct_2b().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.fCurrentPosU = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v9 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v9.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v9.dim.append(val3)
        start = end
        end += 4
        (_v9.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = s.unpack(str[start:end])
        self.fCurrentPosU.append(val1)
      start = end
      end += 48
      self.fCurrentVelU = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.fUserETT = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.fTargetPosU = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.fTargetVelU = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.fRotationMatrixUser = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v10 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v10.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v10.dim.append(val3)
        start = end
        end += 4
        (_v10.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = s.unpack(str[start:end])
        self.fRotationMatrixUser.append(val1)
      start = end
      end += 48
      self.fActualAI = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 3
      self.bActualSW = _get_struct_3B().unpack(str[start:end])
      self.bActualSW = list(map(bool, self.bActualSW))
      start = end
      end += 2
      self.bActualSI = _get_struct_2B().unpack(str[start:end])
      self.bActualSI = list(map(bool, self.bActualSI))
      start = end
      end += 2
      self.iActualAT = _get_struct_2b().unpack(str[start:end])
      start = end
      end += 16
      self.fTargetAO = _get_struct_2d().unpack(str[start:end])
      start = end
      end += 2
      self.iTargetAT = _get_struct_2b().unpack(str[start:end])
      start = end
      end += 2
      self.bActualES = _get_struct_2B().unpack(str[start:end])
      self.bActualES = list(map(bool, self.bActualES))
      start = end
      end += 2
      self.iActualED = _get_struct_2b().unpack(str[start:end])
      start = end
      end += 2
      self.bActualER = _get_struct_2B().unpack(str[start:end])
      self.bActualER = list(map(bool, self.bActualER))
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.robot_state
      buff.write(_get_struct_i().pack(_x))
      _x = self.robot_state_str
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2b().pack(_x.actual_mode, _x.actual_space))
      buff.write(self.current_posj.tostring())
      buff.write(self.current_velj.tostring())
      buff.write(self.joint_abs.tostring())
      buff.write(self.joint_err.tostring())
      buff.write(self.target_posj.tostring())
      buff.write(self.target_velj.tostring())
      buff.write(self.current_posx.tostring())
      buff.write(self.current_tool_posx.tostring())
      buff.write(self.current_velx.tostring())
      buff.write(self.task_err.tostring())
      buff.write(self.target_velx.tostring())
      buff.write(self.target_posx.tostring())
      buff.write(self.dynamic_tor.tostring())
      buff.write(self.actual_jts.tostring())
      buff.write(self.actual_ejt.tostring())
      buff.write(self.actual_ett.tostring())
      buff.write(self.actual_bk.tostring())
      buff.write(self.actual_mc.tostring())
      buff.write(self.actual_mt.tostring())
      _x = self
      buff.write(_get_struct_bd().pack(_x.solution_space, _x.sync_time))
      buff.write(self.actual_bt.tostring())
      length = len(self.rotation_matrix)
      buff.write(_struct_I.pack(length))
      for val1 in self.rotation_matrix:
        _v11 = val1.layout
        length = len(_v11.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v11.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v11.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.data.tostring())
      buff.write(self.ctrlbox_digital_input.tostring())
      buff.write(self.ctrlbox_digital_output.tostring())
      buff.write(self.flange_digital_input.tostring())
      buff.write(self.flange_digital_output.tostring())
      length = len(self.modbus_state)
      buff.write(_struct_I.pack(length))
      for val1 in self.modbus_state:
        _x = val1.modbus_symbol
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.modbus_value
        buff.write(_get_struct_i().pack(_x))
      _x = self
      buff.write(_get_struct_i2Bb2B().pack(_x.access_control, _x.homming_completed, _x.tp_initialized, _x.mastering_need, _x.drl_stopped, _x.disconnected))
      buff.write(self.fActualW2B.tostring())
      length = len(self.fCurrentPosW)
      buff.write(_struct_I.pack(length))
      for val1 in self.fCurrentPosW:
        _v12 = val1.layout
        length = len(_v12.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v12.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v12.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.data.tostring())
      buff.write(self.fCurrentVelW.tostring())
      buff.write(self.fWorldETT.tostring())
      buff.write(self.fTargetPosW.tostring())
      buff.write(self.fTargetVelW.tostring())
      length = len(self.fRotationMatrixWorld)
      buff.write(_struct_I.pack(length))
      for val1 in self.fRotationMatrixWorld:
        _v13 = val1.layout
        length = len(_v13.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v13.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v13.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.data.tostring())
      _x = self
      buff.write(_get_struct_2b().pack(_x.iActualUCN, _x.iParent))
      length = len(self.fCurrentPosU)
      buff.write(_struct_I.pack(length))
      for val1 in self.fCurrentPosU:
        _v14 = val1.layout
        length = len(_v14.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v14.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v14.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.data.tostring())
      buff.write(self.fCurrentVelU.tostring())
      buff.write(self.fUserETT.tostring())
      buff.write(self.fTargetPosU.tostring())
      buff.write(self.fTargetVelU.tostring())
      length = len(self.fRotationMatrixUser)
      buff.write(_struct_I.pack(length))
      for val1 in self.fRotationMatrixUser:
        _v15 = val1.layout
        length = len(_v15.dim)
        buff.write(_struct_I.pack(length))
        for val3 in _v15.dim:
          _x = val3.label
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2I().pack(_x.size, _x.stride))
        _x = _v15.data_offset
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.data.tostring())
      buff.write(self.fActualAI.tostring())
      buff.write(self.bActualSW.tostring())
      buff.write(self.bActualSI.tostring())
      buff.write(self.iActualAT.tostring())
      buff.write(self.fTargetAO.tostring())
      buff.write(self.iTargetAT.tostring())
      buff.write(self.bActualES.tostring())
      buff.write(self.iActualED.tostring())
      buff.write(self.bActualER.tostring())
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.rotation_matrix is None:
        self.rotation_matrix = None
      if self.modbus_state is None:
        self.modbus_state = None
      if self.fCurrentPosW is None:
        self.fCurrentPosW = None
      if self.fRotationMatrixWorld is None:
        self.fRotationMatrixWorld = None
      if self.fCurrentPosU is None:
        self.fCurrentPosU = None
      if self.fRotationMatrixUser is None:
        self.fRotationMatrixUser = None
      end = 0
      start = end
      end += 4
      (self.robot_state,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.robot_state_str = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.robot_state_str = str[start:end]
      _x = self
      start = end
      end += 2
      (_x.actual_mode, _x.actual_space,) = _get_struct_2b().unpack(str[start:end])
      start = end
      end += 48
      self.current_posj = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.current_velj = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.joint_abs = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.joint_err = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.target_posj = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.target_velj = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.current_posx = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.current_tool_posx = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.current_velx = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.task_err = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.target_velx = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.target_posx = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.dynamic_tor = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_jts = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_ejt = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_ett = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 6
      self.actual_bk = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=6)
      start = end
      end += 48
      self.actual_mc = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.actual_mt = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      _x = self
      start = end
      end += 9
      (_x.solution_space, _x.sync_time,) = _get_struct_bd().unpack(str[start:end])
      start = end
      end += 5
      self.actual_bt = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=5)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.rotation_matrix = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v16 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v16.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v16.dim.append(val3)
        start = end
        end += 4
        (_v16.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        self.rotation_matrix.append(val1)
      start = end
      end += 16
      self.ctrlbox_digital_input = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=16)
      start = end
      end += 16
      self.ctrlbox_digital_output = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=16)
      start = end
      end += 6
      self.flange_digital_input = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=6)
      start = end
      end += 6
      self.flange_digital_output = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=6)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.modbus_state = []
      for i in range(0, length):
        val1 = dsr_msgs.msg.ModbusState()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.modbus_symbol = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.modbus_symbol = str[start:end]
        start = end
        end += 4
        (val1.modbus_value,) = _get_struct_i().unpack(str[start:end])
        self.modbus_state.append(val1)
      _x = self
      start = end
      end += 9
      (_x.access_control, _x.homming_completed, _x.tp_initialized, _x.mastering_need, _x.drl_stopped, _x.disconnected,) = _get_struct_i2Bb2B().unpack(str[start:end])
      self.homming_completed = bool(self.homming_completed)
      self.tp_initialized = bool(self.tp_initialized)
      self.drl_stopped = bool(self.drl_stopped)
      self.disconnected = bool(self.disconnected)
      start = end
      end += 48
      self.fActualW2B = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.fCurrentPosW = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v17 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v17.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v17.dim.append(val3)
        start = end
        end += 4
        (_v17.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        self.fCurrentPosW.append(val1)
      start = end
      end += 48
      self.fCurrentVelW = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.fWorldETT = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.fTargetPosW = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.fTargetVelW = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.fRotationMatrixWorld = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v18 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v18.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v18.dim.append(val3)
        start = end
        end += 4
        (_v18.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        self.fRotationMatrixWorld.append(val1)
      _x = self
      start = end
      end += 2
      (_x.iActualUCN, _x.iParent,) = _get_struct_2b().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.fCurrentPosU = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v19 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v19.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v19.dim.append(val3)
        start = end
        end += 4
        (_v19.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        self.fCurrentPosU.append(val1)
      start = end
      end += 48
      self.fCurrentVelU = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.fUserETT = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.fTargetPosU = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.fTargetVelU = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.fRotationMatrixUser = []
      for i in range(0, length):
        val1 = std_msgs.msg.Float64MultiArray()
        _v20 = val1.layout
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v20.dim = []
        for i in range(0, length):
          val3 = std_msgs.msg.MultiArrayDimension()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.label = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.label = str[start:end]
          _x = val3
          start = end
          end += 8
          (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
          _v20.dim.append(val3)
        start = end
        end += 4
        (_v20.data_offset,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        self.fRotationMatrixUser.append(val1)
      start = end
      end += 48
      self.fActualAI = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 3
      self.bActualSW = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=3)
      self.bActualSW = list(map(bool, self.bActualSW))
      start = end
      end += 2
      self.bActualSI = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=2)
      self.bActualSI = list(map(bool, self.bActualSI))
      start = end
      end += 2
      self.iActualAT = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=2)
      start = end
      end += 16
      self.fTargetAO = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=2)
      start = end
      end += 2
      self.iTargetAT = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=2)
      start = end
      end += 2
      self.bActualES = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=2)
      self.bActualES = list(map(bool, self.bActualES))
      start = end
      end += 2
      self.iActualED = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=2)
      start = end
      end += 2
      self.bActualER = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=2)
      self.bActualER = list(map(bool, self.bActualER))
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_16b = None
def _get_struct_16b():
    global _struct_16b
    if _struct_16b is None:
        _struct_16b = struct.Struct("<16b")
    return _struct_16b
_struct_2B = None
def _get_struct_2B():
    global _struct_2B
    if _struct_2B is None:
        _struct_2B = struct.Struct("<2B")
    return _struct_2B
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_2b = None
def _get_struct_2b():
    global _struct_2b
    if _struct_2b is None:
        _struct_2b = struct.Struct("<2b")
    return _struct_2b
_struct_2d = None
def _get_struct_2d():
    global _struct_2d
    if _struct_2d is None:
        _struct_2d = struct.Struct("<2d")
    return _struct_2d
_struct_3B = None
def _get_struct_3B():
    global _struct_3B
    if _struct_3B is None:
        _struct_3B = struct.Struct("<3B")
    return _struct_3B
_struct_5b = None
def _get_struct_5b():
    global _struct_5b
    if _struct_5b is None:
        _struct_5b = struct.Struct("<5b")
    return _struct_5b
_struct_6b = None
def _get_struct_6b():
    global _struct_6b
    if _struct_6b is None:
        _struct_6b = struct.Struct("<6b")
    return _struct_6b
_struct_6d = None
def _get_struct_6d():
    global _struct_6d
    if _struct_6d is None:
        _struct_6d = struct.Struct("<6d")
    return _struct_6d
_struct_bd = None
def _get_struct_bd():
    global _struct_bd
    if _struct_bd is None:
        _struct_bd = struct.Struct("<bd")
    return _struct_bd
_struct_i = None
def _get_struct_i():
    global _struct_i
    if _struct_i is None:
        _struct_i = struct.Struct("<i")
    return _struct_i
_struct_i2Bb2B = None
def _get_struct_i2Bb2B():
    global _struct_i2Bb2B
    if _struct_i2Bb2B is None:
        _struct_i2Bb2B = struct.Struct("<i2Bb2B")
    return _struct_i2Bb2B
