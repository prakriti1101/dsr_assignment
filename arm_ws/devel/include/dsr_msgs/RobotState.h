// Generated by gencpp from file dsr_msgs/RobotState.msg
// DO NOT EDIT!


#ifndef DSR_MSGS_MESSAGE_ROBOTSTATE_H
#define DSR_MSGS_MESSAGE_ROBOTSTATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Float64MultiArray.h>
#include <dsr_msgs/ModbusState.h>
#include <std_msgs/Float64MultiArray.h>
#include <std_msgs/Float64MultiArray.h>
#include <std_msgs/Float64MultiArray.h>
#include <std_msgs/Float64MultiArray.h>

namespace dsr_msgs
{
template <class ContainerAllocator>
struct RobotState_
{
  typedef RobotState_<ContainerAllocator> Type;

  RobotState_()
    : robot_state(0)
    , robot_state_str()
    , actual_mode(0)
    , actual_space(0)
    , current_posj()
    , current_velj()
    , joint_abs()
    , joint_err()
    , target_posj()
    , target_velj()
    , current_posx()
    , current_tool_posx()
    , current_velx()
    , task_err()
    , target_velx()
    , target_posx()
    , dynamic_tor()
    , actual_jts()
    , actual_ejt()
    , actual_ett()
    , actual_bk()
    , actual_mc()
    , actual_mt()
    , solution_space(0)
    , sync_time(0.0)
    , actual_bt()
    , rotation_matrix()
    , ctrlbox_digital_input()
    , ctrlbox_digital_output()
    , flange_digital_input()
    , flange_digital_output()
    , modbus_state()
    , access_control(0)
    , homming_completed(false)
    , tp_initialized(false)
    , mastering_need(0)
    , drl_stopped(false)
    , disconnected(false)
    , fActualW2B()
    , fCurrentPosW()
    , fCurrentVelW()
    , fWorldETT()
    , fTargetPosW()
    , fTargetVelW()
    , fRotationMatrixWorld()
    , iActualUCN(0)
    , iParent(0)
    , fCurrentPosU()
    , fCurrentVelU()
    , fUserETT()
    , fTargetPosU()
    , fTargetVelU()
    , fRotationMatrixUser()
    , fActualAI()
    , bActualSW()
    , bActualSI()
    , iActualAT()
    , fTargetAO()
    , iTargetAT()
    , bActualES()
    , iActualED()
    , bActualER()  {
      current_posj.assign(0.0);

      current_velj.assign(0.0);

      joint_abs.assign(0.0);

      joint_err.assign(0.0);

      target_posj.assign(0.0);

      target_velj.assign(0.0);

      current_posx.assign(0.0);

      current_tool_posx.assign(0.0);

      current_velx.assign(0.0);

      task_err.assign(0.0);

      target_velx.assign(0.0);

      target_posx.assign(0.0);

      dynamic_tor.assign(0.0);

      actual_jts.assign(0.0);

      actual_ejt.assign(0.0);

      actual_ett.assign(0.0);

      actual_bk.assign(0);

      actual_mc.assign(0.0);

      actual_mt.assign(0.0);

      actual_bt.assign(0);

      ctrlbox_digital_input.assign(0);

      ctrlbox_digital_output.assign(0);

      flange_digital_input.assign(0);

      flange_digital_output.assign(0);

      fActualW2B.assign(0.0);

      fCurrentVelW.assign(0.0);

      fWorldETT.assign(0.0);

      fTargetPosW.assign(0.0);

      fTargetVelW.assign(0.0);

      fCurrentVelU.assign(0.0);

      fUserETT.assign(0.0);

      fTargetPosU.assign(0.0);

      fTargetVelU.assign(0.0);

      fActualAI.assign(0.0);

      bActualSW.assign(false);

      bActualSI.assign(false);

      iActualAT.assign(0);

      fTargetAO.assign(0.0);

      iTargetAT.assign(0);

      bActualES.assign(false);

      iActualED.assign(0);

      bActualER.assign(false);
  }
  RobotState_(const ContainerAllocator& _alloc)
    : robot_state(0)
    , robot_state_str(_alloc)
    , actual_mode(0)
    , actual_space(0)
    , current_posj()
    , current_velj()
    , joint_abs()
    , joint_err()
    , target_posj()
    , target_velj()
    , current_posx()
    , current_tool_posx()
    , current_velx()
    , task_err()
    , target_velx()
    , target_posx()
    , dynamic_tor()
    , actual_jts()
    , actual_ejt()
    , actual_ett()
    , actual_bk()
    , actual_mc()
    , actual_mt()
    , solution_space(0)
    , sync_time(0.0)
    , actual_bt()
    , rotation_matrix(_alloc)
    , ctrlbox_digital_input()
    , ctrlbox_digital_output()
    , flange_digital_input()
    , flange_digital_output()
    , modbus_state(_alloc)
    , access_control(0)
    , homming_completed(false)
    , tp_initialized(false)
    , mastering_need(0)
    , drl_stopped(false)
    , disconnected(false)
    , fActualW2B()
    , fCurrentPosW(_alloc)
    , fCurrentVelW()
    , fWorldETT()
    , fTargetPosW()
    , fTargetVelW()
    , fRotationMatrixWorld(_alloc)
    , iActualUCN(0)
    , iParent(0)
    , fCurrentPosU(_alloc)
    , fCurrentVelU()
    , fUserETT()
    , fTargetPosU()
    , fTargetVelU()
    , fRotationMatrixUser(_alloc)
    , fActualAI()
    , bActualSW()
    , bActualSI()
    , iActualAT()
    , fTargetAO()
    , iTargetAT()
    , bActualES()
    , iActualED()
    , bActualER()  {
  (void)_alloc;
      current_posj.assign(0.0);

      current_velj.assign(0.0);

      joint_abs.assign(0.0);

      joint_err.assign(0.0);

      target_posj.assign(0.0);

      target_velj.assign(0.0);

      current_posx.assign(0.0);

      current_tool_posx.assign(0.0);

      current_velx.assign(0.0);

      task_err.assign(0.0);

      target_velx.assign(0.0);

      target_posx.assign(0.0);

      dynamic_tor.assign(0.0);

      actual_jts.assign(0.0);

      actual_ejt.assign(0.0);

      actual_ett.assign(0.0);

      actual_bk.assign(0);

      actual_mc.assign(0.0);

      actual_mt.assign(0.0);

      actual_bt.assign(0);

      ctrlbox_digital_input.assign(0);

      ctrlbox_digital_output.assign(0);

      flange_digital_input.assign(0);

      flange_digital_output.assign(0);

      fActualW2B.assign(0.0);

      fCurrentVelW.assign(0.0);

      fWorldETT.assign(0.0);

      fTargetPosW.assign(0.0);

      fTargetVelW.assign(0.0);

      fCurrentVelU.assign(0.0);

      fUserETT.assign(0.0);

      fTargetPosU.assign(0.0);

      fTargetVelU.assign(0.0);

      fActualAI.assign(0.0);

      bActualSW.assign(false);

      bActualSI.assign(false);

      iActualAT.assign(0);

      fTargetAO.assign(0.0);

      iTargetAT.assign(0);

      bActualES.assign(false);

      iActualED.assign(0);

      bActualER.assign(false);
  }



   typedef int32_t _robot_state_type;
  _robot_state_type robot_state;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _robot_state_str_type;
  _robot_state_str_type robot_state_str;

   typedef int8_t _actual_mode_type;
  _actual_mode_type actual_mode;

   typedef int8_t _actual_space_type;
  _actual_space_type actual_space;

   typedef boost::array<double, 6>  _current_posj_type;
  _current_posj_type current_posj;

   typedef boost::array<double, 6>  _current_velj_type;
  _current_velj_type current_velj;

   typedef boost::array<double, 6>  _joint_abs_type;
  _joint_abs_type joint_abs;

   typedef boost::array<double, 6>  _joint_err_type;
  _joint_err_type joint_err;

   typedef boost::array<double, 6>  _target_posj_type;
  _target_posj_type target_posj;

   typedef boost::array<double, 6>  _target_velj_type;
  _target_velj_type target_velj;

   typedef boost::array<double, 6>  _current_posx_type;
  _current_posx_type current_posx;

   typedef boost::array<double, 6>  _current_tool_posx_type;
  _current_tool_posx_type current_tool_posx;

   typedef boost::array<double, 6>  _current_velx_type;
  _current_velx_type current_velx;

   typedef boost::array<double, 6>  _task_err_type;
  _task_err_type task_err;

   typedef boost::array<double, 6>  _target_velx_type;
  _target_velx_type target_velx;

   typedef boost::array<double, 6>  _target_posx_type;
  _target_posx_type target_posx;

   typedef boost::array<double, 6>  _dynamic_tor_type;
  _dynamic_tor_type dynamic_tor;

   typedef boost::array<double, 6>  _actual_jts_type;
  _actual_jts_type actual_jts;

   typedef boost::array<double, 6>  _actual_ejt_type;
  _actual_ejt_type actual_ejt;

   typedef boost::array<double, 6>  _actual_ett_type;
  _actual_ett_type actual_ett;

   typedef boost::array<int8_t, 6>  _actual_bk_type;
  _actual_bk_type actual_bk;

   typedef boost::array<double, 6>  _actual_mc_type;
  _actual_mc_type actual_mc;

   typedef boost::array<double, 6>  _actual_mt_type;
  _actual_mt_type actual_mt;

   typedef int8_t _solution_space_type;
  _solution_space_type solution_space;

   typedef double _sync_time_type;
  _sync_time_type sync_time;

   typedef boost::array<int8_t, 5>  _actual_bt_type;
  _actual_bt_type actual_bt;

   typedef std::vector< ::std_msgs::Float64MultiArray_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::std_msgs::Float64MultiArray_<ContainerAllocator> >> _rotation_matrix_type;
  _rotation_matrix_type rotation_matrix;

   typedef boost::array<int8_t, 16>  _ctrlbox_digital_input_type;
  _ctrlbox_digital_input_type ctrlbox_digital_input;

   typedef boost::array<int8_t, 16>  _ctrlbox_digital_output_type;
  _ctrlbox_digital_output_type ctrlbox_digital_output;

   typedef boost::array<int8_t, 6>  _flange_digital_input_type;
  _flange_digital_input_type flange_digital_input;

   typedef boost::array<int8_t, 6>  _flange_digital_output_type;
  _flange_digital_output_type flange_digital_output;

   typedef std::vector< ::dsr_msgs::ModbusState_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::dsr_msgs::ModbusState_<ContainerAllocator> >> _modbus_state_type;
  _modbus_state_type modbus_state;

   typedef int32_t _access_control_type;
  _access_control_type access_control;

   typedef uint8_t _homming_completed_type;
  _homming_completed_type homming_completed;

   typedef uint8_t _tp_initialized_type;
  _tp_initialized_type tp_initialized;

   typedef int8_t _mastering_need_type;
  _mastering_need_type mastering_need;

   typedef uint8_t _drl_stopped_type;
  _drl_stopped_type drl_stopped;

   typedef uint8_t _disconnected_type;
  _disconnected_type disconnected;

   typedef boost::array<double, 6>  _fActualW2B_type;
  _fActualW2B_type fActualW2B;

   typedef std::vector< ::std_msgs::Float64MultiArray_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::std_msgs::Float64MultiArray_<ContainerAllocator> >> _fCurrentPosW_type;
  _fCurrentPosW_type fCurrentPosW;

   typedef boost::array<double, 6>  _fCurrentVelW_type;
  _fCurrentVelW_type fCurrentVelW;

   typedef boost::array<double, 6>  _fWorldETT_type;
  _fWorldETT_type fWorldETT;

   typedef boost::array<double, 6>  _fTargetPosW_type;
  _fTargetPosW_type fTargetPosW;

   typedef boost::array<double, 6>  _fTargetVelW_type;
  _fTargetVelW_type fTargetVelW;

   typedef std::vector< ::std_msgs::Float64MultiArray_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::std_msgs::Float64MultiArray_<ContainerAllocator> >> _fRotationMatrixWorld_type;
  _fRotationMatrixWorld_type fRotationMatrixWorld;

   typedef int8_t _iActualUCN_type;
  _iActualUCN_type iActualUCN;

   typedef int8_t _iParent_type;
  _iParent_type iParent;

   typedef std::vector< ::std_msgs::Float64MultiArray_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::std_msgs::Float64MultiArray_<ContainerAllocator> >> _fCurrentPosU_type;
  _fCurrentPosU_type fCurrentPosU;

   typedef boost::array<double, 6>  _fCurrentVelU_type;
  _fCurrentVelU_type fCurrentVelU;

   typedef boost::array<double, 6>  _fUserETT_type;
  _fUserETT_type fUserETT;

   typedef boost::array<double, 6>  _fTargetPosU_type;
  _fTargetPosU_type fTargetPosU;

   typedef boost::array<double, 6>  _fTargetVelU_type;
  _fTargetVelU_type fTargetVelU;

   typedef std::vector< ::std_msgs::Float64MultiArray_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::std_msgs::Float64MultiArray_<ContainerAllocator> >> _fRotationMatrixUser_type;
  _fRotationMatrixUser_type fRotationMatrixUser;

   typedef boost::array<double, 6>  _fActualAI_type;
  _fActualAI_type fActualAI;

   typedef boost::array<uint8_t, 3>  _bActualSW_type;
  _bActualSW_type bActualSW;

   typedef boost::array<uint8_t, 2>  _bActualSI_type;
  _bActualSI_type bActualSI;

   typedef boost::array<int8_t, 2>  _iActualAT_type;
  _iActualAT_type iActualAT;

   typedef boost::array<double, 2>  _fTargetAO_type;
  _fTargetAO_type fTargetAO;

   typedef boost::array<int8_t, 2>  _iTargetAT_type;
  _iTargetAT_type iTargetAT;

   typedef boost::array<uint8_t, 2>  _bActualES_type;
  _bActualES_type bActualES;

   typedef boost::array<int8_t, 2>  _iActualED_type;
  _iActualED_type iActualED;

   typedef boost::array<uint8_t, 2>  _bActualER_type;
  _bActualER_type bActualER;





  typedef boost::shared_ptr< ::dsr_msgs::RobotState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::dsr_msgs::RobotState_<ContainerAllocator> const> ConstPtr;

}; // struct RobotState_

typedef ::dsr_msgs::RobotState_<std::allocator<void> > RobotState;

typedef boost::shared_ptr< ::dsr_msgs::RobotState > RobotStatePtr;
typedef boost::shared_ptr< ::dsr_msgs::RobotState const> RobotStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::dsr_msgs::RobotState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::dsr_msgs::RobotState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::dsr_msgs::RobotState_<ContainerAllocator1> & lhs, const ::dsr_msgs::RobotState_<ContainerAllocator2> & rhs)
{
  return lhs.robot_state == rhs.robot_state &&
    lhs.robot_state_str == rhs.robot_state_str &&
    lhs.actual_mode == rhs.actual_mode &&
    lhs.actual_space == rhs.actual_space &&
    lhs.current_posj == rhs.current_posj &&
    lhs.current_velj == rhs.current_velj &&
    lhs.joint_abs == rhs.joint_abs &&
    lhs.joint_err == rhs.joint_err &&
    lhs.target_posj == rhs.target_posj &&
    lhs.target_velj == rhs.target_velj &&
    lhs.current_posx == rhs.current_posx &&
    lhs.current_tool_posx == rhs.current_tool_posx &&
    lhs.current_velx == rhs.current_velx &&
    lhs.task_err == rhs.task_err &&
    lhs.target_velx == rhs.target_velx &&
    lhs.target_posx == rhs.target_posx &&
    lhs.dynamic_tor == rhs.dynamic_tor &&
    lhs.actual_jts == rhs.actual_jts &&
    lhs.actual_ejt == rhs.actual_ejt &&
    lhs.actual_ett == rhs.actual_ett &&
    lhs.actual_bk == rhs.actual_bk &&
    lhs.actual_mc == rhs.actual_mc &&
    lhs.actual_mt == rhs.actual_mt &&
    lhs.solution_space == rhs.solution_space &&
    lhs.sync_time == rhs.sync_time &&
    lhs.actual_bt == rhs.actual_bt &&
    lhs.rotation_matrix == rhs.rotation_matrix &&
    lhs.ctrlbox_digital_input == rhs.ctrlbox_digital_input &&
    lhs.ctrlbox_digital_output == rhs.ctrlbox_digital_output &&
    lhs.flange_digital_input == rhs.flange_digital_input &&
    lhs.flange_digital_output == rhs.flange_digital_output &&
    lhs.modbus_state == rhs.modbus_state &&
    lhs.access_control == rhs.access_control &&
    lhs.homming_completed == rhs.homming_completed &&
    lhs.tp_initialized == rhs.tp_initialized &&
    lhs.mastering_need == rhs.mastering_need &&
    lhs.drl_stopped == rhs.drl_stopped &&
    lhs.disconnected == rhs.disconnected &&
    lhs.fActualW2B == rhs.fActualW2B &&
    lhs.fCurrentPosW == rhs.fCurrentPosW &&
    lhs.fCurrentVelW == rhs.fCurrentVelW &&
    lhs.fWorldETT == rhs.fWorldETT &&
    lhs.fTargetPosW == rhs.fTargetPosW &&
    lhs.fTargetVelW == rhs.fTargetVelW &&
    lhs.fRotationMatrixWorld == rhs.fRotationMatrixWorld &&
    lhs.iActualUCN == rhs.iActualUCN &&
    lhs.iParent == rhs.iParent &&
    lhs.fCurrentPosU == rhs.fCurrentPosU &&
    lhs.fCurrentVelU == rhs.fCurrentVelU &&
    lhs.fUserETT == rhs.fUserETT &&
    lhs.fTargetPosU == rhs.fTargetPosU &&
    lhs.fTargetVelU == rhs.fTargetVelU &&
    lhs.fRotationMatrixUser == rhs.fRotationMatrixUser &&
    lhs.fActualAI == rhs.fActualAI &&
    lhs.bActualSW == rhs.bActualSW &&
    lhs.bActualSI == rhs.bActualSI &&
    lhs.iActualAT == rhs.iActualAT &&
    lhs.fTargetAO == rhs.fTargetAO &&
    lhs.iTargetAT == rhs.iTargetAT &&
    lhs.bActualES == rhs.bActualES &&
    lhs.iActualED == rhs.iActualED &&
    lhs.bActualER == rhs.bActualER;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::dsr_msgs::RobotState_<ContainerAllocator1> & lhs, const ::dsr_msgs::RobotState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace dsr_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::dsr_msgs::RobotState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::dsr_msgs::RobotState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::dsr_msgs::RobotState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::dsr_msgs::RobotState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::dsr_msgs::RobotState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::dsr_msgs::RobotState_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::dsr_msgs::RobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "0473bf35fc3b2d88cf36052d2ba4677e";
  }

  static const char* value(const ::dsr_msgs::RobotState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x0473bf35fc3b2d88ULL;
  static const uint64_t static_value2 = 0xcf36052d2ba4677eULL;
};

template<class ContainerAllocator>
struct DataType< ::dsr_msgs::RobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "dsr_msgs/RobotState";
  }

  static const char* value(const ::dsr_msgs::RobotState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::dsr_msgs::RobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#____________________________________________________________________________________________\n"
"# state of robot\n"
"#____________________________________________________________________________________________\n"
"\n"
"int32       robot_state             # 0 : STATE_INITIALIZING,   1 : STATE_STANDBY,   2 : STATE_MOVING,    3 : STATE_SAFE_OFF\n"
"                                    # 4 : STATE_TEACHING,       5 : STATE_SAFE_STOP, 6 : STATE_EMERGENCY_STOP,\n"
"                                    # 7 : STATE_EMERGENCY_STOP, 8 : STATE_HOMMING,   9 : STATE_RECOVERY,  10: STATE_SAFE_STOP2,     \n"
"                                    # 11: STATE_SAFE_OFF2,      12: STATE_RESERVED1, 13: STATE_RESERVED2, 14: STATE_RESERVED3,\n"
"                                    # 15: STATE_NOT_READY       16: STATE_LAST\n"
"string      robot_state_str         # Convert robot_state id to string\n"
"\n"
"int8        actual_mode             # position control: 0, torque control: 1\n"
"int8        actual_space            # joint space: 0, task space: 1\n"
"\n"
"float64[6]  current_posj            # current joint angle list [degree] \n"
"float64[6]  current_velj            # current joint velocity list []\n"
"float64[6]  joint_abs               # Position Actual Value in ABS\n"
"float64[6]  joint_err               # Joint Error\n"
"float64[6]  target_posj             # target joint angle list [degree] \n"
"float64[6]  target_velj             # target joint velocity list []\n"
"\n"
"float64[6]  current_posx            # current task angle list []\n"
"float64[6]  current_tool_posx       # current task tool angle list []\n"
"float64[6]  current_velx            # current task velocity list []\n"
"float64[6]  task_err                # Task Error\n"
"float64[6]  target_velx             # target task velocity list []       \n"
"float64[6]  target_posx             # target task position list []\n"
"  \n"
"float64[6]  dynamic_tor             # dynamic torque\n"
"float64[6]  actual_jts              # joint torque sensor\n"
"float64[6]  actual_ejt              # external joint torque\n"
"float64[6]  actual_ett              # external tool torque\n"
"\n"
"int8[6]     actual_bk               # brake status \n"
"float64[6]  actual_mc               # motor current \n"
"float64[6]  actual_mt               # motor temperature\n"
"\n"
"int8        solution_space          # Solution Space (0 ~ 7)\n"
"float64     sync_time               # internal clock counter   \n"
"int8[5]     actual_bt               # cockpit(robot button) info.\n"
"std_msgs/Float64MultiArray[] rotation_matrix  # Rotation Matrix [3][3]\n"
"\n"
"\n"
"int8[16]    ctrlbox_digital_input   # Digital Input in Control Box(0 ~ 15 ; 0 : ON, 1 : OFF)\n"
"int8[16]    ctrlbox_digital_output  # Digital Output in Control Box(0 ~ 15 ; 0 : ON, 1 : OFF)\n"
"\n"
"int8[6]     flange_digital_input    # Digital Input in Flange(0 ~ 5 ; 0 : ON, 1 : OFF) x1 port : 0 ~ 2, x2 port : 3 ~ 5\n"
"int8[6]     flange_digital_output   # Digital Output in Flange(0 ~ 5 ; 0 : ON, 1 : OFF)\n"
"\n"
"ModbusState[] modbus_state          # Custom msg for modbus state(refer to ModbusState.msg)\n"
"int32 	    access_control          # \n"
"bool	    homming_completed       #\n"
"bool	    tp_initialized          #\n"
"int8	    mastering_need          #\n"
"bool	    drl_stopped             #\n"
"bool	    disconnected            #\n"
"\n"
"#____________________________________________________________________________________________\n"
"# The following messages have been updated since version M2.50 or higher.\n"
"#____________________________________________________________________________________________\n"
"float64[6]  fActualW2B                               # world to base releation\n"
"std_msgs/Float64MultiArray[] fCurrentPosW            # Wolrd position actual value [2][6] : (0: tool, 1: flange) [mm, degree] \n"
"float64[6]  fCurrentVelW                             # World velocity Actual Value [mm/sec, degree/sec]\n"
"float64[6]  fWorldETT                                # External Task Force/Torque [N, Nm]\n"
"float64[6]  fTargetPosW                              # World target Position [mm, degree]\n"
"float64[6]  fTargetVelW                              # World target Velocity [mm/sec, degree/sec]\n"
"std_msgs/Float64MultiArray[] fRotationMatrixWorld    # World rotation matrix [3][3]\n"
"int8        iActualUCN                               # Actual user coord number ## 101 ~ 120\n"
"int8        iParent                                  # Coordinate Reference(base : 0  world : 2)\n"
"std_msgs/Float64MultiArray[] fCurrentPosU            # User position Actual Value [2][6] : (0:tool, 1:flange) [mm, degree]\n"
"float64[6]  fCurrentVelU                             # User velocity Actual Value [mm/sec, degree/sec]\n"
"float64[6]  fUserETT                                 # External Task Force/Torque [N, Nm]\n"
"float64[6]  fTargetPosU                              # User target Position [mm, degree]\n"
"float64[6]  fTargetVelU                              # User target Velocity [mm/sec, degree/sec]\n"
"std_msgs/Float64MultiArray[] fRotationMatrixUser     # User rotation matrix [3][3] \n"
"float64[6]  fActualAI                                # Analog input data ## Current mode : 0~20.0[mA] , Voltage mode : 0~10.0[V]\n"
"bool[3]     bActualSW                                # Switch input data[3] \n"
"bool[2]     bActualSI                                # Safety input data[2]\n"
"int8[2]     iActualAT                                # Analog input type[2]  index = channel, type: current(0), voltage(1)  \n"
"float64[2]    fTargetAO                              # Analog output data ## Current mode : 0~20.0[mA] , Voltage mode : 0~10.0[V]\n"
"int8[2]     iTargetAT                                # Analog output type[2] index = channel, type: current(0), voltage(1)\n"
"bool[2]     bActualES                                # Encorder strove signal\n"
"int8[2]     iActualED                                # Encorder raw data   \n"
"bool[2]     bActualER                                # Encorder reset signal\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Float64MultiArray\n"
"# Please look at the MultiArrayLayout message definition for\n"
"# documentation on all multiarrays.\n"
"\n"
"MultiArrayLayout  layout        # specification of data layout\n"
"float64[]         data          # array of data\n"
"\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/MultiArrayLayout\n"
"# The multiarray declares a generic multi-dimensional array of a\n"
"# particular data type.  Dimensions are ordered from outer most\n"
"# to inner most.\n"
"\n"
"MultiArrayDimension[] dim # Array of dimension properties\n"
"uint32 data_offset        # padding elements at front of data\n"
"\n"
"# Accessors should ALWAYS be written in terms of dimension stride\n"
"# and specified outer-most dimension first.\n"
"# \n"
"# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n"
"#\n"
"# A standard, 3-channel 640x480 image with interleaved color channels\n"
"# would be specified as:\n"
"#\n"
"# dim[0].label  = \"height\"\n"
"# dim[0].size   = 480\n"
"# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n"
"# dim[1].label  = \"width\"\n"
"# dim[1].size   = 640\n"
"# dim[1].stride = 3*640 = 1920\n"
"# dim[2].label  = \"channel\"\n"
"# dim[2].size   = 3\n"
"# dim[2].stride = 3\n"
"#\n"
"# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/MultiArrayDimension\n"
"string label   # label of given dimension\n"
"uint32 size    # size of given dimension (in type units)\n"
"uint32 stride  # stride of given dimension\n"
"================================================================================\n"
"MSG: dsr_msgs/ModbusState\n"
"#____________________________________________________________________________________________\n"
"#Custom msg for RobotState.msg -- MAX_SIZE = 100\n"
"#____________________________________________________________________________________________\n"
"\n"
"string  modbus_symbol    # Modbus Signal Name\n"
"int32   modbus_value     # Modbus Register Value (Unsigned : 0 ~ 65535)\n"
;
  }

  static const char* value(const ::dsr_msgs::RobotState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::dsr_msgs::RobotState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.robot_state);
      stream.next(m.robot_state_str);
      stream.next(m.actual_mode);
      stream.next(m.actual_space);
      stream.next(m.current_posj);
      stream.next(m.current_velj);
      stream.next(m.joint_abs);
      stream.next(m.joint_err);
      stream.next(m.target_posj);
      stream.next(m.target_velj);
      stream.next(m.current_posx);
      stream.next(m.current_tool_posx);
      stream.next(m.current_velx);
      stream.next(m.task_err);
      stream.next(m.target_velx);
      stream.next(m.target_posx);
      stream.next(m.dynamic_tor);
      stream.next(m.actual_jts);
      stream.next(m.actual_ejt);
      stream.next(m.actual_ett);
      stream.next(m.actual_bk);
      stream.next(m.actual_mc);
      stream.next(m.actual_mt);
      stream.next(m.solution_space);
      stream.next(m.sync_time);
      stream.next(m.actual_bt);
      stream.next(m.rotation_matrix);
      stream.next(m.ctrlbox_digital_input);
      stream.next(m.ctrlbox_digital_output);
      stream.next(m.flange_digital_input);
      stream.next(m.flange_digital_output);
      stream.next(m.modbus_state);
      stream.next(m.access_control);
      stream.next(m.homming_completed);
      stream.next(m.tp_initialized);
      stream.next(m.mastering_need);
      stream.next(m.drl_stopped);
      stream.next(m.disconnected);
      stream.next(m.fActualW2B);
      stream.next(m.fCurrentPosW);
      stream.next(m.fCurrentVelW);
      stream.next(m.fWorldETT);
      stream.next(m.fTargetPosW);
      stream.next(m.fTargetVelW);
      stream.next(m.fRotationMatrixWorld);
      stream.next(m.iActualUCN);
      stream.next(m.iParent);
      stream.next(m.fCurrentPosU);
      stream.next(m.fCurrentVelU);
      stream.next(m.fUserETT);
      stream.next(m.fTargetPosU);
      stream.next(m.fTargetVelU);
      stream.next(m.fRotationMatrixUser);
      stream.next(m.fActualAI);
      stream.next(m.bActualSW);
      stream.next(m.bActualSI);
      stream.next(m.iActualAT);
      stream.next(m.fTargetAO);
      stream.next(m.iTargetAT);
      stream.next(m.bActualES);
      stream.next(m.iActualED);
      stream.next(m.bActualER);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RobotState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::dsr_msgs::RobotState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::dsr_msgs::RobotState_<ContainerAllocator>& v)
  {
    s << indent << "robot_state: ";
    Printer<int32_t>::stream(s, indent + "  ", v.robot_state);
    s << indent << "robot_state_str: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.robot_state_str);
    s << indent << "actual_mode: ";
    Printer<int8_t>::stream(s, indent + "  ", v.actual_mode);
    s << indent << "actual_space: ";
    Printer<int8_t>::stream(s, indent + "  ", v.actual_space);
    s << indent << "current_posj[]" << std::endl;
    for (size_t i = 0; i < v.current_posj.size(); ++i)
    {
      s << indent << "  current_posj[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.current_posj[i]);
    }
    s << indent << "current_velj[]" << std::endl;
    for (size_t i = 0; i < v.current_velj.size(); ++i)
    {
      s << indent << "  current_velj[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.current_velj[i]);
    }
    s << indent << "joint_abs[]" << std::endl;
    for (size_t i = 0; i < v.joint_abs.size(); ++i)
    {
      s << indent << "  joint_abs[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_abs[i]);
    }
    s << indent << "joint_err[]" << std::endl;
    for (size_t i = 0; i < v.joint_err.size(); ++i)
    {
      s << indent << "  joint_err[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_err[i]);
    }
    s << indent << "target_posj[]" << std::endl;
    for (size_t i = 0; i < v.target_posj.size(); ++i)
    {
      s << indent << "  target_posj[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.target_posj[i]);
    }
    s << indent << "target_velj[]" << std::endl;
    for (size_t i = 0; i < v.target_velj.size(); ++i)
    {
      s << indent << "  target_velj[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.target_velj[i]);
    }
    s << indent << "current_posx[]" << std::endl;
    for (size_t i = 0; i < v.current_posx.size(); ++i)
    {
      s << indent << "  current_posx[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.current_posx[i]);
    }
    s << indent << "current_tool_posx[]" << std::endl;
    for (size_t i = 0; i < v.current_tool_posx.size(); ++i)
    {
      s << indent << "  current_tool_posx[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.current_tool_posx[i]);
    }
    s << indent << "current_velx[]" << std::endl;
    for (size_t i = 0; i < v.current_velx.size(); ++i)
    {
      s << indent << "  current_velx[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.current_velx[i]);
    }
    s << indent << "task_err[]" << std::endl;
    for (size_t i = 0; i < v.task_err.size(); ++i)
    {
      s << indent << "  task_err[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.task_err[i]);
    }
    s << indent << "target_velx[]" << std::endl;
    for (size_t i = 0; i < v.target_velx.size(); ++i)
    {
      s << indent << "  target_velx[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.target_velx[i]);
    }
    s << indent << "target_posx[]" << std::endl;
    for (size_t i = 0; i < v.target_posx.size(); ++i)
    {
      s << indent << "  target_posx[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.target_posx[i]);
    }
    s << indent << "dynamic_tor[]" << std::endl;
    for (size_t i = 0; i < v.dynamic_tor.size(); ++i)
    {
      s << indent << "  dynamic_tor[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.dynamic_tor[i]);
    }
    s << indent << "actual_jts[]" << std::endl;
    for (size_t i = 0; i < v.actual_jts.size(); ++i)
    {
      s << indent << "  actual_jts[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.actual_jts[i]);
    }
    s << indent << "actual_ejt[]" << std::endl;
    for (size_t i = 0; i < v.actual_ejt.size(); ++i)
    {
      s << indent << "  actual_ejt[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.actual_ejt[i]);
    }
    s << indent << "actual_ett[]" << std::endl;
    for (size_t i = 0; i < v.actual_ett.size(); ++i)
    {
      s << indent << "  actual_ett[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.actual_ett[i]);
    }
    s << indent << "actual_bk[]" << std::endl;
    for (size_t i = 0; i < v.actual_bk.size(); ++i)
    {
      s << indent << "  actual_bk[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.actual_bk[i]);
    }
    s << indent << "actual_mc[]" << std::endl;
    for (size_t i = 0; i < v.actual_mc.size(); ++i)
    {
      s << indent << "  actual_mc[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.actual_mc[i]);
    }
    s << indent << "actual_mt[]" << std::endl;
    for (size_t i = 0; i < v.actual_mt.size(); ++i)
    {
      s << indent << "  actual_mt[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.actual_mt[i]);
    }
    s << indent << "solution_space: ";
    Printer<int8_t>::stream(s, indent + "  ", v.solution_space);
    s << indent << "sync_time: ";
    Printer<double>::stream(s, indent + "  ", v.sync_time);
    s << indent << "actual_bt[]" << std::endl;
    for (size_t i = 0; i < v.actual_bt.size(); ++i)
    {
      s << indent << "  actual_bt[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.actual_bt[i]);
    }
    s << indent << "rotation_matrix[]" << std::endl;
    for (size_t i = 0; i < v.rotation_matrix.size(); ++i)
    {
      s << indent << "  rotation_matrix[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::std_msgs::Float64MultiArray_<ContainerAllocator> >::stream(s, indent + "    ", v.rotation_matrix[i]);
    }
    s << indent << "ctrlbox_digital_input[]" << std::endl;
    for (size_t i = 0; i < v.ctrlbox_digital_input.size(); ++i)
    {
      s << indent << "  ctrlbox_digital_input[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.ctrlbox_digital_input[i]);
    }
    s << indent << "ctrlbox_digital_output[]" << std::endl;
    for (size_t i = 0; i < v.ctrlbox_digital_output.size(); ++i)
    {
      s << indent << "  ctrlbox_digital_output[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.ctrlbox_digital_output[i]);
    }
    s << indent << "flange_digital_input[]" << std::endl;
    for (size_t i = 0; i < v.flange_digital_input.size(); ++i)
    {
      s << indent << "  flange_digital_input[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.flange_digital_input[i]);
    }
    s << indent << "flange_digital_output[]" << std::endl;
    for (size_t i = 0; i < v.flange_digital_output.size(); ++i)
    {
      s << indent << "  flange_digital_output[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.flange_digital_output[i]);
    }
    s << indent << "modbus_state[]" << std::endl;
    for (size_t i = 0; i < v.modbus_state.size(); ++i)
    {
      s << indent << "  modbus_state[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::dsr_msgs::ModbusState_<ContainerAllocator> >::stream(s, indent + "    ", v.modbus_state[i]);
    }
    s << indent << "access_control: ";
    Printer<int32_t>::stream(s, indent + "  ", v.access_control);
    s << indent << "homming_completed: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.homming_completed);
    s << indent << "tp_initialized: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.tp_initialized);
    s << indent << "mastering_need: ";
    Printer<int8_t>::stream(s, indent + "  ", v.mastering_need);
    s << indent << "drl_stopped: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.drl_stopped);
    s << indent << "disconnected: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.disconnected);
    s << indent << "fActualW2B[]" << std::endl;
    for (size_t i = 0; i < v.fActualW2B.size(); ++i)
    {
      s << indent << "  fActualW2B[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.fActualW2B[i]);
    }
    s << indent << "fCurrentPosW[]" << std::endl;
    for (size_t i = 0; i < v.fCurrentPosW.size(); ++i)
    {
      s << indent << "  fCurrentPosW[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::std_msgs::Float64MultiArray_<ContainerAllocator> >::stream(s, indent + "    ", v.fCurrentPosW[i]);
    }
    s << indent << "fCurrentVelW[]" << std::endl;
    for (size_t i = 0; i < v.fCurrentVelW.size(); ++i)
    {
      s << indent << "  fCurrentVelW[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.fCurrentVelW[i]);
    }
    s << indent << "fWorldETT[]" << std::endl;
    for (size_t i = 0; i < v.fWorldETT.size(); ++i)
    {
      s << indent << "  fWorldETT[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.fWorldETT[i]);
    }
    s << indent << "fTargetPosW[]" << std::endl;
    for (size_t i = 0; i < v.fTargetPosW.size(); ++i)
    {
      s << indent << "  fTargetPosW[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.fTargetPosW[i]);
    }
    s << indent << "fTargetVelW[]" << std::endl;
    for (size_t i = 0; i < v.fTargetVelW.size(); ++i)
    {
      s << indent << "  fTargetVelW[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.fTargetVelW[i]);
    }
    s << indent << "fRotationMatrixWorld[]" << std::endl;
    for (size_t i = 0; i < v.fRotationMatrixWorld.size(); ++i)
    {
      s << indent << "  fRotationMatrixWorld[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::std_msgs::Float64MultiArray_<ContainerAllocator> >::stream(s, indent + "    ", v.fRotationMatrixWorld[i]);
    }
    s << indent << "iActualUCN: ";
    Printer<int8_t>::stream(s, indent + "  ", v.iActualUCN);
    s << indent << "iParent: ";
    Printer<int8_t>::stream(s, indent + "  ", v.iParent);
    s << indent << "fCurrentPosU[]" << std::endl;
    for (size_t i = 0; i < v.fCurrentPosU.size(); ++i)
    {
      s << indent << "  fCurrentPosU[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::std_msgs::Float64MultiArray_<ContainerAllocator> >::stream(s, indent + "    ", v.fCurrentPosU[i]);
    }
    s << indent << "fCurrentVelU[]" << std::endl;
    for (size_t i = 0; i < v.fCurrentVelU.size(); ++i)
    {
      s << indent << "  fCurrentVelU[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.fCurrentVelU[i]);
    }
    s << indent << "fUserETT[]" << std::endl;
    for (size_t i = 0; i < v.fUserETT.size(); ++i)
    {
      s << indent << "  fUserETT[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.fUserETT[i]);
    }
    s << indent << "fTargetPosU[]" << std::endl;
    for (size_t i = 0; i < v.fTargetPosU.size(); ++i)
    {
      s << indent << "  fTargetPosU[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.fTargetPosU[i]);
    }
    s << indent << "fTargetVelU[]" << std::endl;
    for (size_t i = 0; i < v.fTargetVelU.size(); ++i)
    {
      s << indent << "  fTargetVelU[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.fTargetVelU[i]);
    }
    s << indent << "fRotationMatrixUser[]" << std::endl;
    for (size_t i = 0; i < v.fRotationMatrixUser.size(); ++i)
    {
      s << indent << "  fRotationMatrixUser[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::std_msgs::Float64MultiArray_<ContainerAllocator> >::stream(s, indent + "    ", v.fRotationMatrixUser[i]);
    }
    s << indent << "fActualAI[]" << std::endl;
    for (size_t i = 0; i < v.fActualAI.size(); ++i)
    {
      s << indent << "  fActualAI[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.fActualAI[i]);
    }
    s << indent << "bActualSW[]" << std::endl;
    for (size_t i = 0; i < v.bActualSW.size(); ++i)
    {
      s << indent << "  bActualSW[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.bActualSW[i]);
    }
    s << indent << "bActualSI[]" << std::endl;
    for (size_t i = 0; i < v.bActualSI.size(); ++i)
    {
      s << indent << "  bActualSI[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.bActualSI[i]);
    }
    s << indent << "iActualAT[]" << std::endl;
    for (size_t i = 0; i < v.iActualAT.size(); ++i)
    {
      s << indent << "  iActualAT[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.iActualAT[i]);
    }
    s << indent << "fTargetAO[]" << std::endl;
    for (size_t i = 0; i < v.fTargetAO.size(); ++i)
    {
      s << indent << "  fTargetAO[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.fTargetAO[i]);
    }
    s << indent << "iTargetAT[]" << std::endl;
    for (size_t i = 0; i < v.iTargetAT.size(); ++i)
    {
      s << indent << "  iTargetAT[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.iTargetAT[i]);
    }
    s << indent << "bActualES[]" << std::endl;
    for (size_t i = 0; i < v.bActualES.size(); ++i)
    {
      s << indent << "  bActualES[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.bActualES[i]);
    }
    s << indent << "iActualED[]" << std::endl;
    for (size_t i = 0; i < v.iActualED.size(); ++i)
    {
      s << indent << "  iActualED[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.iActualED[i]);
    }
    s << indent << "bActualER[]" << std::endl;
    for (size_t i = 0; i < v.bActualER.size(); ++i)
    {
      s << indent << "  bActualER[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.bActualER[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // DSR_MSGS_MESSAGE_ROBOTSTATE_H
